\chapter{Známé metody hledání modelů}

Jak, jsme viděli v minulé kapitole, najít model
velikosti $n$ nebo ukázat, že neexistuje, je snadné --
stačí použít metodu generuj a testuj.
Tuto metodu lze jednoduše implementovat,
kvůli své pomalosti je však prakticky nepoužitelná.
V této kapitole budeme studovat pokročilejší metody
pro hledání modelů, které jsou obvykle rychlejší
než metoda generuj a testuj.
Začneme popisem základních variant metod MACE a SEM,
poté popíšeme modifikace obou metod.
Metody MACE a SEM interně pracují s klauzulemi bez proměnných
a interpretace reprezentují explicitně,
na konci kapitoly pak zmíníme metody, které interně
pracují s klauzulemi s proměnnými a interpretace reprezentují
implicitně.

\section{Metody MACE a SEM}

Obě metody řeší následující úlohu:
Vstupem úlohy je konečná množina
klauzulí $\clauses$ a velikost domény $n_\sort$
pro každou sortu $\sort \in \sorts'$, kde $\sorts'$ je množina
obsahující právě sorty z $\clauses$. Výstupem úlohy jsou číselné modely
nad $\sorts' \cup \funcs' \cup \preds'$, kde domény mají velikosti
$n_\sort$ a $\funcs'$ resp. $\preds'$ je množina obsahující právě funkční
resp. predikátové symboly z $\clauses$.

Všimněme si, že zadání úlohy jednoznačně určuje domény sort
(domény jsou počátečním úsekem $\nat0$ a známe i jejich velikosti).
Díky tomu jsou hledané modely jednoznačně určeny pouze funkcemi a relacemi.
Navíc víme, nad jakými množinami jsou funkce i relace definovány.
Označme $D_\sort = \{ 0 \comdots n_\sort - 1 \}$ doménu
sorty $\sort \in \sorts'$.
Každému funkčnímu symbolu $\func \in \funcs'$ arity
$\langle \sort_1 \comdots \sort_n, \sort \rangle$ pak model přiřazuje funkci
$f^\interp : D_{\sort_1} \timdots D_{\sort_n} \to D_\sort$
a každému predikátovému symbolu $\pred \in \preds'$ arity
$\langle \sort_1 \comdots \sort_n \rangle$
je přiřazena relace $P^\interp \subseteq D_{\sort_1} \timdots D_{\sort_n}$.

\newcommand\cells{\ensuremath{\mathcal{C}}}

Tyto funkce a relace můžeme reprezentovat tabulkou.
Funkce $\func^\interp$ přiřazená symbolu $\func$
s aritou $\langle \sort_1 \comdots \sort_n, \sort \rangle$
je reprezentována tabulkou o rozměrech $n_{\sort_1} \timdots n_{\sort_n}$,
kde buňky tabulky obsahují prvky z $D_\sort$.
\[
\cells_\func = \bigl\{ \func(i_1 \comdots i_n) \bigm| i_j \in D_{\sort_j},
  \text{ kde } j \in \{ 1 \comdots n  \}  \bigr\}
\]
je množina buněk tabulky pro funkci $\func^\interp$.
Buňka $\func(i_1 \comdots i_n)$ obsahuje hodnotu $v$ (zapisujeme
$\func(i_1 \comdots i_n) = v$) právě tehdy,
když $\func^\interp(i_1 \comdots i_n) = v$.

Relace $\pred^\interp$
přiřazená predikátovému symbolu $\pred$ s aritou
$\langle \sort_1 \comdots \sort_n \rangle$
je reprezentována tabulkou o rozměrech $n_{\sort_1} \timdots n_{\sort_n}$,
kde buňky tabulky obsahují prvky 0 nebo 1.
\[
\cells_\pred = \bigl\{ \pred(i_1 \comdots i_n) \bigm| i_j \in D_{\sort_j},
  \text{ kde } j \in \{ 1 \comdots n  \}  \bigr\}
\]
je množina buněk tabulky pro relaci $\pred^\interp$.
Fakt, že buňka $\pred(i_1 \comdots i_n)$ obsahuje hodnotu $v$
zapisujeme $\pred(i_1 \comdots i_n) = v$.
Buňka $\pred(i_1 \comdots i_n)$ obsahuje hodnotu 1
právě tehdy, když $(i_1 \comdots i_n) \in \pred^\interp$.

% Poznámka: Aplikace funkčních resp. predikátových symbolů bez argumentů
% budeme zapisovat bez prázdných závorek tj. c resp. P
% a nikoliv c() resp. P().

V dalším textu budeme hledání modelů metodami MACE a SEM chápat jako
vyplňování tabulek funkcí a relací.

\subsection{MACE -- základní varianta}

Metoda MACE je popsána v \cite{mccune94davis-putnam}.
Jak jsme již řekli v úvodu, metoda MACE převádí problém na SAT.
Napřed vytvoříme instanci SATu, jejíž řešení odpovídají 1 ku 1
tabulkám funkcí\footnote{Pro funkce v této práci používáme přímé kódování.
Existují však i jiné možnosti.
Pokud bychom například chtěli mít méně
výrokových proměnných pro funkce, mohli bychom použít logaritmické kódování.
Nicméně množství proměnných pro funkce nebývá problém,
neboť se obvykle pracuje pouze s malými doménami.
Naopak problém je horší propagace logaritmického kódování.
Různá kódování včetně přímého a logaritmického jsou popsána
v \cite{gavanelli2007}.} a relací:

% Z předchocízho textu je zřejmé, že
% tabulky funkcí a relací odpovídají číselným
% interpretacím nad $\sorts' \cup \funcs' \cup \preds'$, kde doména
% $\sort \in \sorts'$ má velikost $n_\sort$:

\begin{itemize}
\item[1)] Pro každou funkci $\func^\interp$, jejíž tabulku chceme vyplnit:
  \begin{itemize}
  \item[a)] Pro každou buňku $\func(i_1 \comdots i_n)$ a hodnotu $v$,
    kterou daná buňka může obsahovat, přidáme výrokovou proměnnou
    $A_{\func(i_1 \comdots i_n) = v}$.
  \item[b)] Pro každou buňku $\func(i_1 \comdots i_n)$
    a dvojici hodnot $v < v'$,
    které buňka může obsahovat, přidáme klauzuli
    $\neg A_{\func(i_1 \comdots i_n) = v} \vee \neg A_{\func(i_1 \comdots i_n) = v'}$.
  \item[c)] Pro každou buňku $\func(i_1 \comdots i_n)$ a všechny hodnoty
    $0 \comdots v$, jenž může obsahovat, přidáme klauzuli
    $A_{\func(i_1 \comdots i_n) = 0} \vee \cdots \vee A_{\func(i_1 \comdots i_n) = v}$.
  \end{itemize}
\item[2)] Pro každou relaci $\pred^\interp$, jejíž tabulku chceme vyplnit: Pro
  každou buňku $\pred(i_1 \comdots i_n)$ přidáme výrokovou proměnnou
  $A_{\pred(i_1 \comdots i_n) = 1}$.
\end{itemize}

Na základě řešení instance SATu můžeme vyplnit tabulky funkcí a relací:
Výrok $V$ o buňce tabulky bude pravdivý právě tehdy,
když výroková proměnná $A_V$ má v řešení hodnotu 1.
Klauzule z kroku 1b) zajišťují, že každá buňka obsahuje
nejvýše jednu hodnotu. Klauzule z kroku 1c) zajišťují, že každá
buňka obsahuje alespoň jednu hodnotu.

Tabulky, které takto získáme, nejsou nutně modely $\clauses$.
Aby tomu tak bylo, rozšíříme instanci SATu o další výrokové klauzule,
které získáme zakódováním klauzulí z $\clauses$ do výrokové logiky.
Uvažme například klauzuli
$\clause_1 = \{ \func(\var, \varY) \approx \var \vee \funcC \approx \var \}$,
kde $\func$ je funkční symbol arity
$\langle \sort_1, \sort_2, \sort_1 \rangle$, $\funcC$
je funkční symbol arity $\langle \sort_1 \rangle$ a sorta $\sort_1$
resp. $\sort_2$
má doménu velikosti 3 resp. 2.
Aby tabulky symbolů $\func$ a $\funcC$ byly modelem klauzule
$\clause_1$, musí platit následující podmínky:
\begin{gather*}
  \func(0, 0) = 0 \text{ nebo } \funcC = 0 \\
  \func(1, 0) = 1 \text{ nebo } \funcC = 1 \\
  \func(2, 0) = 2 \text{ nebo } \funcC = 2 \\
  \func(0, 1) = 0 \text{ nebo } \funcC = 0 \\
  \func(1, 1) = 1 \text{ nebo } \funcC = 1 \\
  \func(2, 1) = 2 \text{ nebo } \funcC = 2
\end{gather*}
Uvedené podmínky se skládají z výroků, jenž přímo odpovídají
vý\-ro\-ko\-vým pro\-měnným.
Díky tomu můžeme podmínky snadno zakódovat do výrokových klauzulí:
\begin{gather*}
  A_{\func(0, 0) = 0} \vee A_{\funcC = 0} \\
  A_{\func(1, 0) = 1} \vee A_{\funcC = 1} \\
  A_{\func(2, 0) = 2} \vee A_{\funcC = 2} \\
  A_{\func(0, 1) = 0} \vee A_{\funcC = 0} \\
  A_{\func(1, 1) = 1} \vee A_{\funcC = 1} \\
  A_{\func(2, 1) = 2} \vee A_{\funcC = 2}
\end{gather*}

Klauzuli $\clause_1$ jsme tedy zakódovali do 6 výrokových klauzulí,
které přidáme do naší instance SATu.
Bohužel, ne každou klauzuli jde zakódovat takto přímočaře.
Například, aby tabulky symbolů byly modelem klauzule
$\clause_2 = \func(\funcC, \varY) \approx \funcC$, musí platit podmínky
\begin{gather*}
  \func(\funcC, 0) = \funcC \\
  \func(\funcC, 1) = \funcC
\end{gather*}
Na rozdíl od podmínek pro $\clause_1$ výroky v podmínkách pro $\clause_2$
neodpovídají přímo výrokovým proměnným.
Odpovídaly by, kdybychom znali přesnou hodnotu $\funcC$, jenže tu neznáme.
Víme však, že $\funcC$ má jednu z hodnot 0, 1, nebo 2, nabízí se tedy
použít podmiňování. Pokud má $\funcC$ hodnotu 0, pak musí platit
podmínky
\begin{gather*}
  \func(0, 0) = 0 \\
  \func(0, 1) = 0
\end{gather*}
pokud má $\funcC$ hodnotu 1, musí platit
\begin{gather*}
  \func(1, 0) = 1 \\
  \func(1, 1) = 1
\end{gather*}
a nakonec, pokud má $\funcC$ hodnotu 2, musí platit
\begin{gather*}
  \func(2, 0) = 2 \\
  \func(2, 1) = 2
\end{gather*}
Tyto podmínky již do výrokových klauzulí zakódujeme snadno:
\begin{gather*}
  A_{\funcC = 0} \implies A_{\func(0, 0) = 0} \\
  A_{\funcC = 0} \implies A_{\func(0, 1) = 0} \\
  A_{\funcC = 1} \implies A_{\func(1, 0) = 1} \\
  A_{\funcC = 1} \implies A_{\func(1, 1) = 1} \\
  A_{\funcC = 2} \implies A_{\func(2, 0) = 2} \\
  A_{\funcC = 2} \implies A_{\func(2, 1) = 2}
\end{gather*}

Klauzule, které lze zakódovat do výrokových klauzulí
bez podmiňování, nazveme ploché:

\begin{defn}
Klauzule je plochá, pokud má každý atom jeden z následujících tvarů
\begin{itemize}
\item $\func(\var_1 \comdots \var_n) \approx \varY$
  (případně $\varY \approx \func(\var_1 \comdots \var_n)$,
\item $\pred(\var_1 \comdots \var_n)$,
\item nebo $\var \approx \varY$,
\end{itemize}
kde $\func, \pred, \var, \var_1 \comdots \var_n, \varY$ jsou
vhodně zvolené symboly a proměnné.
\end{defn}

Pomocí těchto dvou pravidel můžeme zploštit každou
klauzuli $\clause$:
\begin{itemize}
\item Je-li $\term$ term, jenž se vyskytuje v $\clause$, a $\var$ proměnná,
  jenž se v $\clause$ nevyskytuje, pak klauzuli $\clause$ můžeme
  nahradit novou klauzulí $\neg (\term \approx \var) \vee \clause$.
\item Je-li $\lit$ literál z $\clause$ tvaru $\neg (\term \approx \var)$,
  že $\term$ neobsahuje $\var$,
  pak můžeme $\clause$ nahradit novou klauzulí, kde je jeden výskyt $\term$
  mimo $\lit$ nahrazen $\var$.
\end{itemize}
Navíc má nová klauzule stejné modely jako původní klauzule.

Použití pravidel pro zplošťování si ukážeme na klauzuli $\clause_2$.
Klauzule $\clause_2$ není plochá, neboť obsahuje atom
$\func(\funcC, \varY) \approx \funcC$, který nemá požadovaný tvar
(atom může obsahovat nejvýše jeden výskyt funkčního nebo predikátového
symbolu). Potřebujeme tedy nahradit $\funcC$ proměnnou.
Napřed použijeme první pravidlo a ke klauzuli $\clause_2$ přidáme literál
$\neg (\funcC \approx \var)$, tj. dostaneme novou klauzuli
$\clause_2' = \neg (\funcC \approx \var) \vee
  \func(\funcC, \varY) \approx \funcC$.
Na klauzuli $\clause_2'$ pak můžeme použít dvakrát druhé pravidlo
a nahradit dva výskyty $\funcC$ proměnnou $\var$, čímž
dostaneme plochou klauzuli
$\clause_2'' = \neg (\funcC \approx \var) \vee
\func(\var, \varY) \approx \var$.

Kdybychom zakódovali
$\clause_2''$ do výrokových klauzulí, dostali bychom stejné klauzule,
jako při kódování $\clause_2$ s pomocí podmiňování.
V dalším textu již budeme používat výhradně zplošťování,
důvodem je, že zplošťování může plně nahradit
podmiňování\footnote{Podmiňování je vlastně zplošťování
přímo integrované do procesu, který transformuje klauzule z $\clauses$
na výrokové klauzule. My jsme tento složitější proces rozdělili na dva
jednodušší procesy -- prvním je zplošťování a druhým je transformace
plochých klauzulí z $\clauses$ na výrokové klauzule. Nyní
můžeme oba procesy vylepšovat zvlášť, případně vložit další procesy mezi
ně, což by jinak nebylo možné.}.
Později zplošťování rozšíříme o další pravidla,
díky nimž v některých případech dostaneme méně výrokových klauzulí,
než kdybychom použili podmiňování.

Kódujeme-li plochou klauzuli $\clause$ do výrokových klauzulí,
počet výrokových klauzulí závisí exponenciálně na počtu proměnných
v $\clause$.
Nepříjemnou vlastností zplošťování je, že jeho první pravidlo
zvyšuje počet proměnných v klauzuli. Tato nepříjemnost je hlavní motivací
pro metodu, jenž si nyní představíme.

\subsection{SEM -- základní varianta}

Metoda SEM je popsána v \cite{zhang1995sem}.
Na rozdíl od metody MACE metoda SEM problém nikam nepřevádí, ale rovnou
ho sama řeší.
Pro popis metody SEM budeme předpokládat $v, v' \in \nat0$ a $c$ je buňka.

Metoda SEM sestává ze dvou funkcí \textproc{Search} a \textproc{Propagate}.
Tyto funkce reprezentují stav řešeného problému jako
pětici $(A_\funcs, A_\preds, U_\funcs, U_\preds, E)$:
% U \funcs a \preds nejsou apostrofy -- dolním indexem
% chceme naznačit, že se množina A_\funcs týká funkcí a A_\preds
% týká predikátů.

% A - assigned.
% U - unassigned.
% E - ensure.

% Místo C (jako constraints nebo clauses) používáme E,
% C již označuje klauzule.
\begin{itemize}
\item Množiny $A_\funcs$ a $A_\preds$ obsahují buňky,
  jimž byla přiřazena hodnota. $A_\funcs$ je množina dvojic
  $(c, v)$, kde $c$ je buňka funkce a $v$
  je hodnota přiřazená této buňce. $A_\preds$ je množina
  jejíž prvky mají tvar $c$ nebo $\neg c$, kde $c$ je buňka
  relace. Je-li $c \in A_\preds$, pak je buňce $c$ přiřazena hodnota 1,
  je-li $\neg c \in A_\preds$, pak je buňce $c$ přiřazena hodnota 0.
\item Množiny $U_\funcs$ a $U_\preds$ obsahují buňky,
  jimž nebyla přiřazena hodnota. $U_\funcs$ je množina
  dvojic $(c, D)$, kde $c$ je buňka funkce a $D$
  je množina hodnot, jenž lze přiřadit buňce.
  $U_\preds$ je množina buněk relací.
% Poznámka: Komponenty nemusí být nutně literály podle definice
% z předchozí kapitoly, nicméně nebezpečí nedorozumnění nehrozí.
\item $E$ je množina podmínek, které zbývá splnit.
  Každá podmínka je disjunkce komponent, těmto komponentám
  budeme říkat literály.
\end{itemize}
Invariantem je, že každá buňka má právě jeden výskyt
v právě jedné z~množin $A_\funcs, A_\preds, U_\funcs, U_\preds$.
Konflikt nastává v okamžiku, kdy se v $E$ objeví podmínka bez literálů
nebo kdy se v $U_\funcs$ objeví dvojice tvaru $(c, \emptyset)$.
Model je nalezen v okamžiku, kdy jsou všechny podmínky
splněny (množina $E$ je prázdná) a každé buňce je přiřazena
hodnota (množiny $U_\funcs$ a $U_\preds$ jsou prázdné).
Model je určen množinami $A_\funcs$ a $A_\preds$.

Funkce \textproc{Search} je definována následovně:
\medskip
\begin{algorithmic}
\Function{Search}{$A_\funcs, A_\preds, U_\funcs, U_\preds, E$}
  \State $r \gets \Call{Propagate}{A_\funcs, A_\preds, U_\funcs, U_\preds, E}$
  \If{$r \neq \text{\texttt{conflict}}$}
    \State $(A_\funcs, A_\preds, U_\funcs, U_\preds, E) \gets r$
    \If{$U_\funcs \cup U_\preds = \emptyset$}
      \State \textbf{print model} $(A_\funcs, A_\preds)$
    \Else
      \State $c \gets$ vyber buňku z $U_\funcs \cup U_\preds$
      \If{$(c, D) \in U_\funcs$ pro nějaké $D$}
        \For{$v \in D$}
          \State \Call{Search}{$A_\funcs \cup \{ (c, v) \}, A_\preds,
            U_\funcs \setminus \{ (c, D) \}, U_\preds, E$}
        \EndFor
      \Else
        \State \Call{Search}{$A_\funcs, A_\preds \cup \{ c \},
          U_\funcs, U_\preds \setminus \{ c \}, E$}
        \State \Call{Search}{$A_\funcs, A_\preds \cup \{ \neg c \},
          U_\funcs, U_\preds \setminus \{ c \}, E$}
      \EndIf
    \EndIf
  \EndIf
\EndFunction
\end{algorithmic}
\medskip

Vstupem funkce \textproc{Search} je již zmíněná pětice
$(A_\funcs, A_\preds, U_\funcs, U_\preds, E)$. Výstupem funkce
\textproc{Search} jsou modely, pro výpis modelů se používá příkaz
\textbf{print model}.

Na začátku metoda SEM zavolá funkci \textproc{Search} s argumenty
\begin{align*}
A_\funcs &= \emptyset \\
A_\preds &= \emptyset \\
U_\funcs &=
  \bigl\{ (c, D_\sort) \bigm|
    \func \in \funcs',
    \sort \text{ je sorta výsledku } \func,
    c \in \cells_\func \bigr\} \\
U_\preds &=
  \bigl\{ c \bigm|
    \pred \in \preds',
    c \in \cells_\pred \bigr\} \\
E &=
  \Bigl\{ e \Bigm|
    \array{c}
        e \text{ vznikne z $\clause \in \clauses$ použitím substituce,
                která každou} \\[-0.3ex]
      \text{proměnnou $\var$ z $\clause$ nahradí hodnotou z $D_\sort$, kde $\sort$
            je sorta $\var$}
    \endarray
    \Bigr\}
\end{align*}
Výstupem takového volání jsou hledané modely.
Funkce \textproc{Search} používá pomocnou funkci \textproc{Propagate}.
Jejím vstupem je opět pětice
$(A_\funcs, A_\preds, U_\funcs, U_\preds, E)$.
Funkce \textproc{Propagate} pak na danou pětici opakovaně
aplikuje ná\-sle\-du\-jící pravidla, dokud nenastane konflikt nebo
dokud se pětice mění:
\begin{itemize}
% Pravidlo 1 z clanku o SEM:
\item Pro každé $(c, v) \in A_\funcs$ nahradit všechny výskyty $c$ v $E$
  hodnotou $v$.
% Odstranovani splnenych podminek a nesplnenych literalu
% (v clanku o SEM jsou tyto pravidla implicitni):
\item Pro každé $v, v'$ takové, že $v \neq v'$:
  \begin{itemize}
  \item Z $E$ odebrat podmínky, jenž obsahují literál $v \approx v$
    nebo literál $\neg (v \approx v')$ nebo literál z $A_\preds$.
  \item Z každé podmínky v $E$ odebrat literály tvaru $\neg (v \approx v)$,
    literály tvaru $v \approx v'$ a literály tvaru $\neg \lit$,
    kde $\lit \in A_\preds$.
  \end{itemize}
% Pravidlo 1b z clanku o SEM:
\item Pro každou podmínku s jedním literálem tvaru $c \approx v$
  (resp. $v \approx c$),
  kde $(c, D) \in U_\funcs$ pro nějaké $D$,
  odebrat $(c, D)$ z $U_\funcs$
  a přidat $(c, v)$ do $A_\funcs$.
\item Pro každou podmínku s jedním literálem tvaru $\neg (c \approx v)$
  (resp. $\neg (v \approx c)$),
  kde $(c, D) \in U_\funcs$ pro nějaké $D$,
  odebrat $v$ z $D$.
% Pravidlo 1a z clanku o SEM:
\item Pro každou podmínku s jedním literálem tvaru $c$,
  kde $c \in U_\preds$,
  odebrat $c$ z $U_\preds$
  a přidat $c$ do $A_\preds$.
\item Pro každou podmínku s jedním literálem tvaru $\neg c$,
  kde $c \in U_\preds$,
  odebrat $c$ z $U_\preds$
  a přidat $\neg c$ do $A_\preds$.
% Pravidlo 3 z clanku o SEM:
\item Pro každou dvojici $(c, \{ v \}) \in U_\funcs$
  odebrat $(c, \{ v \})$ z $U_\funcs$
  a přidat $(c, v)$ do $A_\funcs$.
\end{itemize}

V případě, že nastal konflikt, funkce
\textproc{Propagate} vrátí hodnotou \texttt{conflict},
v opačném případě je vrácena nová pětice.

\subsection{Modifikace metod MACE a SEM}
