\chapter{Známé metody hledání modelů}

Jak, jsme viděli v minulé kapitole, najít model
velikosti $n$ nebo ukázat, že neexistuje, je snadné --
stačí použít metodu generuj a testuj.
Tuto metodu lze jednoduše implementovat,
kvůli své pomalosti je však prakticky nepoužitelná.
V této kapitole budeme studovat pokročilejší metody
pro hledání modelů, které jsou obvykle rychlejší
než metoda generuj a testuj.
Začneme popisem základních variant metod MACE a SEM,
poté popíšeme modifikace obou metod.
Metody MACE a SEM interně pracují s klauzulemi bez proměnných
a interpretace reprezentují explicitně,
na konci kapitoly pak zmíníme metody, které interně
pracují s klauzulemi s proměnnými a interpretace reprezentují
implicitně.

\section{Metody MACE a SEM}

Obě metody řeší následující úlohu:
Vstupem úlohy je konečná množina
klauzulí $\clauses$ a velikost domény $n_\sort$
pro každou sortu $\sort \in \sorts'$, kde $\sorts'$ je množina
obsahující právě sorty z $\clauses$. Výstupem úlohy jsou číselné modely
nad $\sorts' \cup \funcs' \cup \preds'$, kde domény mají velikosti
$n_\sort$ a $\funcs'$ resp. $\preds'$ je množina obsahující právě funkční
resp. predikátové symboly z $\clauses$.

Všimněme si, že zadání úlohy jednoznačně určuje domény sort
(domény jsou počátečním úsekem $\natZ$ a známe i jejich velikosti).
Díky tomu jsou hledané modely jednoznačně určeny pouze funkcemi a relacemi.
Navíc víme, nad jakými množinami jsou funkce i relace definovány.
Označme $D_\sort = \{ 0 \comdots n_\sort - 1 \}$ doménu
sorty $\sort \in \sorts'$.
Každému funkčnímu symbolu $\func \in \funcs'$ arity
$\langle \sort_1 \comdots \sort_n, \sort \rangle$ pak model přiřazuje funkci
$f^\interp : D_{\sort_1} \timdots D_{\sort_n} \to D_\sort$
a každému predikátovému symbolu $\pred \in \preds'$ arity
$\langle \sort_1 \comdots \sort_n \rangle$
je přiřazena relace $P^\interp \subseteq D_{\sort_1} \timdots D_{\sort_n}$.

\newcommand\cells{\ensuremath{\mathcal{C}}}

Tyto funkce a relace můžeme reprezentovat tabulkou.
Funkce $\func^\interp$ přiřazená symbolu $\func$
s aritou $\langle \sort_1 \comdots \sort_n, \sort \rangle$
je reprezentována tabulkou o rozměrech $n_{\sort_1} \timdots n_{\sort_n}$,
kde buňky tabulky obsahují prvky z $D_\sort$.
\[
\cells_\func = \bigl\{ \func(i_1 \comdots i_n) \bigm| i_j \in D_{\sort_j},
  \text{ kde } j \in \{ 1 \comdots n  \}  \bigr\}
\]
je množina buněk tabulky pro funkci $\func^\interp$.
Buňka $\func(i_1 \comdots i_n)$ obsahuje hodnotu $v$ (zapisujeme
$\func(i_1 \comdots i_n) = v$) právě tehdy,
když $\func^\interp(i_1 \comdots i_n) = v$.

Relace $\pred^\interp$
přiřazená predikátovému symbolu $\pred$ s aritou
$\langle \sort_1 \comdots \sort_n \rangle$
je reprezentována tabulkou o rozměrech $n_{\sort_1} \timdots n_{\sort_n}$,
kde buňky tabulky obsahují prvky 0 nebo 1.
\[
\cells_\pred = \bigl\{ \pred(i_1 \comdots i_n) \bigm| i_j \in D_{\sort_j},
  \text{ kde } j \in \{ 1 \comdots n  \}  \bigr\}
\]
je množina buněk tabulky pro relaci $\pred^\interp$.
Fakt, že buňka $\pred(i_1 \comdots i_n)$ obsahuje hodnotu $v$
zapisujeme $\pred(i_1 \comdots i_n) = v$.
Buňka $\pred(i_1 \comdots i_n)$ obsahuje hodnotu 1
právě tehdy, když $(i_1 \comdots i_n) \in \pred^\interp$.

% Poznámka: Aplikace funkčních resp. predikátových symbolů bez argumentů
% budeme zapisovat bez prázdných závorek tj. c resp. P
% a nikoliv c() resp. P().

V dalším textu budeme hledání modelů metodami MACE a SEM chápat jako
vyplňování tabulek funkcí a relací.

\subsection{MACE -- základní varianta}

Metoda MACE je popsána v \cite{mccune94davis-putnam}.
Jak jsme již řekli v úvodu, metoda MACE převádí problém na SAT.
Napřed vytvoříme instanci SATu, jejíž řešení odpovídají 1 ku 1
tabulkám funkcí\footnote{Pro funkce v této práci používáme přímé kódování.
Existují však i jiné možnosti.
Pokud bychom například chtěli mít méně
výrokových proměnných pro funkce, mohli bychom použít logaritmické kódování.
Nicméně množství proměnných pro funkce nebývá problém,
neboť se obvykle pracuje pouze s malými doménami.
Naopak problém je horší propagace logaritmického kódování.
Různá kódování včetně přímého a logaritmického jsou popsána
v \cite{gavanelli2007}.} a relací:

% Z předchocízho textu je zřejmé, že
% tabulky funkcí a relací odpovídají číselným
% interpretacím nad $\sorts' \cup \funcs' \cup \preds'$, kde doména
% $\sort \in \sorts'$ má velikost $n_\sort$:

\begin{itemize}
\item[1)] Pro každou funkci $\func^\interp$, jejíž tabulku chceme vyplnit:
  \begin{itemize}
  \item[a)] Pro každou buňku $\func(i_1 \comdots i_n)$ a hodnotu $v$,
    kterou daná buňka může obsahovat, přidáme výrokovou proměnnou
    $A_{\func(i_1 \comdots i_n) = v}$.
  \item[b)] Pro každou buňku $\func(i_1 \comdots i_n)$
    a dvojici hodnot $v < v'$,
    které buňka může obsahovat, přidáme klauzuli
    $\neg A_{\func(i_1 \comdots i_n) = v} \vee \neg A_{\func(i_1 \comdots i_n) = v'}$.
  \item[c)] Pro každou buňku $\func(i_1 \comdots i_n)$ a všechny hodnoty
    $0 \comdots v$, jenž může obsahovat, přidáme klauzuli
    $A_{\func(i_1 \comdots i_n) = 0} \vee \cdots \vee A_{\func(i_1 \comdots i_n) = v}$.
  \end{itemize}
\item[2)] Pro každou relaci $\pred^\interp$, jejíž tabulku chceme vyplnit: Pro
  každou buňku $\pred(i_1 \comdots i_n)$ přidáme výrokovou proměnnou
  $A_{\pred(i_1 \comdots i_n) = 1}$.
\end{itemize}

Na základě řešení instance SATu můžeme vyplnit tabulky funkcí a relací:
Výrok $V$ o buňce tabulky bude pravdivý právě tehdy,
když výroková proměnná $A_V$ má v řešení hodnotu 1.
Klauzule z kroku 1b) zajišťují, že každá buňka obsahuje
nejvýše jednu hodnotu. Klauzule z kroku 1c) zajišťují, že každá
buňka obsahuje alespoň jednu hodnotu.

Tabulky, které takto získáme, nejsou nutně modely $\clauses$.
Aby tomu tak bylo, rozšíříme instanci SATu o další výrokové klauzule,
které získáme zakódováním klauzulí z $\clauses$ do výrokové logiky.
Uvažme například klauzuli
$\clause_1 = \{ \func(\var, \varY) \approx \var \vee \funcC \approx \var \}$,
kde $\func$ je funkční symbol arity
$\langle \sort_1, \sort_2, \sort_1 \rangle$, $\funcC$
je funkční symbol arity $\langle \sort_1 \rangle$ a sorta $\sort_1$
resp. $\sort_2$
má doménu velikosti 3 resp. 2.
Aby tabulky symbolů $\func$ a $\funcC$ byly modelem klauzule
$\clause_1$, musí platit následující podmínky:
\begin{gather*}
  \func(0, 0) = 0 \text{ nebo } \funcC = 0, \\
  \func(1, 0) = 1 \text{ nebo } \funcC = 1, \\
  \func(2, 0) = 2 \text{ nebo } \funcC = 2, \\
  \func(0, 1) = 0 \text{ nebo } \funcC = 0, \\
  \func(1, 1) = 1 \text{ nebo } \funcC = 1, \\
  \func(2, 1) = 2 \text{ nebo } \funcC = 2.
\end{gather*}
Uvedené podmínky se skládají z výroků, jenž přímo odpovídají
vý\-ro\-ko\-vým pro\-měnným.
Díky tomu můžeme podmínky snadno zakódovat do výrokových klauzulí:
\begin{gather*}
  A_{\func(0, 0) = 0} \vee A_{\funcC = 0}, \\
  A_{\func(1, 0) = 1} \vee A_{\funcC = 1}, \\
  A_{\func(2, 0) = 2} \vee A_{\funcC = 2}, \\
  A_{\func(0, 1) = 0} \vee A_{\funcC = 0}, \\
  A_{\func(1, 1) = 1} \vee A_{\funcC = 1}, \\
  A_{\func(2, 1) = 2} \vee A_{\funcC = 2}.
\end{gather*}

Klauzuli $\clause_1$ jsme tedy zakódovali do 6 výrokových klauzulí,
které přidáme do naší instance SATu.
Bohužel, ne každou klauzuli jde zakódovat takto přímočaře.
Například, aby tabulky symbolů byly modelem klauzule
$\clause_2 = \func(\funcC, \varY) \approx \funcC$, musí platit podmínky
\begin{gather*}
  \func(\funcC, 0) = \funcC, \\
  \func(\funcC, 1) = \funcC.
\end{gather*}
Na rozdíl od podmínek pro $\clause_1$ výroky v podmínkách pro $\clause_2$
neodpovídají přímo výrokovým proměnným.
Odpovídaly by, kdybychom znali přesnou hodnotu $\funcC$, jenže tu neznáme.
Víme však, že $\funcC$ má jednu z hodnot 0, 1, nebo 2, nabízí se tedy
použít podmiňování. Pokud má $\funcC$ hodnotu 0, pak musí platit
podmínky
\begin{gather*}
  \func(0, 0) = 0, \\
  \func(0, 1) = 0,
\end{gather*}
pokud má $\funcC$ hodnotu 1, musí platit
\begin{gather*}
  \func(1, 0) = 1, \\
  \func(1, 1) = 1,
\end{gather*}
a nakonec, pokud má $\funcC$ hodnotu 2, musí platit
\begin{gather*}
  \func(2, 0) = 2, \\
  \func(2, 1) = 2.
\end{gather*}
Tyto podmínky již do výrokových klauzulí zakódujeme snadno:
\begin{gather*}
  A_{\funcC = 0} \implies A_{\func(0, 0) = 0}, \\
  A_{\funcC = 0} \implies A_{\func(0, 1) = 0}, \\
  A_{\funcC = 1} \implies A_{\func(1, 0) = 1}, \\
  A_{\funcC = 1} \implies A_{\func(1, 1) = 1}, \\
  A_{\funcC = 2} \implies A_{\func(2, 0) = 2}, \\
  A_{\funcC = 2} \implies A_{\func(2, 1) = 2}.
\end{gather*}

Klauzule, které lze zakódovat do výrokových klauzulí
bez podmiňování, nazveme ploché:

\begin{defn}
Klauzule je plochá, pokud má každý atom jeden z následujících tvarů
\begin{itemize}
\item $\func(\var_1 \comdots \var_n) \approx \varY$
  (případně $\varY \approx \func(\var_1 \comdots \var_n)$,
\item $\pred(\var_1 \comdots \var_n)$,
\item nebo $\var \approx \varY$,
\end{itemize}
kde $\func, \pred, \var, \var_1 \comdots \var_n, \varY$ jsou
vhodně zvolené symboly a proměnné.
\end{defn}

Pomocí těchto dvou pravidel můžeme zploštit každou
klauzuli $\clause$:
\begin{itemize}
\item Je-li $\term$ term, jenž se vyskytuje v $\clause$, a $\var$ proměnná,
  jenž se v $\clause$ nevyskytuje, pak klauzuli $\clause$ můžeme
  nahradit novou klauzulí $\term \not\approx \var \vee \clause$.
\item Je-li $\lit$ literál z $\clause$ tvaru $\term \not\approx \var$
  (resp. $\var \not\approx \term$),
  že $\term$ neobsahuje $\var$,
  pak můžeme $\clause$ upravit tak, že jeden výskyt $\term$
  mimo $\lit$ nahradíme $\var$.
\end{itemize}
Navíc má nová klauzule stejné modely jako původní klauzule.

Použití pravidel pro zplošťování si ukážeme na klauzuli $\clause_2$.
Klauzule $\clause_2$ není plochá, neboť obsahuje atom
$\func(\funcC, \varY) \approx \funcC$, který nemá požadovaný tvar
(atom může obsahovat nejvýše jeden výskyt funkčního nebo predikátového
symbolu). Potřebujeme tedy nahradit $\funcC$ proměnnou.
Napřed použijeme první pravidlo a ke klauzuli $\clause_2$ přidáme literál
$\funcC \not\approx \var$, tj. dostaneme novou klauzuli
$\clause_2' = \funcC \not\approx \var \vee
  \func(\funcC, \varY) \approx \funcC$.
Na klauzuli $\clause_2'$ pak můžeme použít dvakrát druhé pravidlo
a nahradit dva výskyty $\funcC$ proměnnou $\var$, čímž
dostaneme plochou klauzuli
$\clause_2'' = \funcC \not\approx \var \vee
\func(\var, \varY) \approx \var$.

Kdybychom zakódovali
$\clause_2''$ do výrokových klauzulí, dostali bychom stejné klauzule,
jako při kódování $\clause_2$ s pomocí podmiňování.
V dalším textu již budeme používat výhradně zplošťování,
důvodem je, že zplošťování může plně nahradit
podmiňování\footnote{Podmiňování je vlastně zplošťování
přímo integrované do procesu, který transformuje klauzule z $\clauses$
na výrokové klauzule. My jsme tento složitější proces rozdělili na dva
jednodušší procesy -- prvním je zplošťování a druhým je transformace
plochých klauzulí z $\clauses$ na výrokové klauzule. Nyní
můžeme oba procesy vylepšovat zvlášť, případně vložit další procesy mezi
ně, což by jinak nebylo možné.}.
Později zplošťování rozšíříme o další pravidla,
díky nimž v některých případech dostaneme méně výrokových klauzulí,
než kdybychom použili podmiňování.

Kódujeme-li plochou klauzuli $\clause$ do výrokových klauzulí,
počet výrokových klauzulí závisí exponenciálně na počtu proměnných
v $\clause$.
Nepříjemnou vlastností zplošťování je, že jeho první pravidlo
zvyšuje počet proměnných v klauzuli. Tato nepříjemnost je hlavní motivací
pro metodu, jenž si nyní představíme.

\subsection{SEM -- základní varianta}

Metoda SEM je popsána v \cite{zhang1995sem}.
Na rozdíl od metody MACE metoda SEM problém nikam nepřevádí, ale rovnou
ho sama řeší.
Pro popis metody SEM budeme předpokládat $v, v' \in \natZ$ a $c$ je buňka.

Metoda SEM sestává ze dvou funkcí \textproc{Search} a \textproc{Propagate}.
Tyto funkce reprezentují stav řešeného problému jako
pětici $(A_\funcs, A_\preds, U_\funcs, U_\preds, E)$:
% U \funcs a \preds nejsou apostrofy -- dolním indexem
% chceme naznačit, že se množina A_\funcs týká funkcí a A_\preds
% týká predikátů.

% A - assigned.
% U - unassigned.
% E - ensure.

% Místo C (jako constraints nebo clauses) používáme E,
% C již označuje klauzule.
\begin{itemize}
\item Množiny $A_\funcs$ a $A_\preds$ obsahují buňky,
  jimž byla přiřazena hodnota. $A_\funcs$ je množina dvojic
  $(c, v)$, kde $c$ je buňka funkce a $v$
  je hodnota přiřazená této buňce. $A_\preds$ je množina
  jejíž prvky mají tvar $c$ nebo $\neg c$, kde $c$ je buňka
  relace. Je-li $c \in A_\preds$, pak je buňce $c$ přiřazena hodnota 1,
  je-li $\neg c \in A_\preds$, pak je buňce $c$ přiřazena hodnota 0.
\item Množiny $U_\funcs$ a $U_\preds$ obsahují buňky,
  jimž nebyla přiřazena hodnota. $U_\funcs$ je množina
  dvojic $(c, D)$, kde $c$ je buňka funkce a $D$
  je množina hodnot, jenž lze přiřadit buňce.
  $U_\preds$ je množina buněk relací.
% Poznámka: Komponenty nemusí být nutně literály podle definice
% z předchozí kapitoly, nicméně nebezpečí nedorozumnění nehrozí.
\item $E$ je množina podmínek, které zbývá splnit.
  Každá podmínka je disjunkce komponent, těmto komponentám
  budeme říkat literály.
\end{itemize}
Invariantem je, že každá buňka má právě jeden výskyt
v právě jedné z~množin $A_\funcs, A_\preds, U_\funcs, U_\preds$.
Konflikt nastává v okamžiku, kdy se v $E$ objeví podmínka bez literálů
nebo kdy se v $U_\funcs$ objeví dvojice tvaru $(c, \emptyset)$.
Model je nalezen v okamžiku, kdy jsou všechny podmínky
splněny (množina $E$ je prázdná) a každé buňce je přiřazena
hodnota (množiny $U_\funcs$ a $U_\preds$ jsou prázdné).
Model je určen množinami $A_\funcs$ a $A_\preds$.

Funkce \textproc{Search} je definována následovně:
\medskip
\begin{algorithmic}
\Function{Search}{$A_\funcs, A_\preds, U_\funcs, U_\preds, E$}
  \State $r \gets \Call{Propagate}{A_\funcs, A_\preds, U_\funcs, U_\preds, E}$
  \If{$r \neq \text{\texttt{conflict}}$}
    \State $(A_\funcs, A_\preds, U_\funcs, U_\preds, E) \gets r$
    \If{$U_\funcs \cup U_\preds = \emptyset$}
      \State \textbf{print model} $(A_\funcs, A_\preds)$
    \Else
      \State $c \gets$ vyber buňku z $U_\funcs \cup U_\preds$
      \If{$(c, D) \in U_\funcs$ pro nějaké $D$}
        \For{$v \in D$}
          \State \Call{Search}{$A_\funcs \cup \{ (c, v) \}, A_\preds,
            U_\funcs \setminus \{ (c, D) \}, U_\preds, E$}
        \EndFor
      \Else
        \State \Call{Search}{$A_\funcs, A_\preds \cup \{ c \},
          U_\funcs, U_\preds \setminus \{ c \}, E$}
        \State \Call{Search}{$A_\funcs, A_\preds \cup \{ \neg c \},
          U_\funcs, U_\preds \setminus \{ c \}, E$}
      \EndIf
    \EndIf
  \EndIf
\EndFunction
\end{algorithmic}
\medskip

Vstupem funkce \textproc{Search} je již zmíněná pětice
$(A_\funcs, A_\preds, U_\funcs, U_\preds, E)$. Výstupem funkce
\textproc{Search} jsou modely, pro výpis modelů se používá příkaz
\textbf{print model}.

Na začátku metoda SEM zavolá funkci \textproc{Search} s argumenty
\begin{align*}
A_\funcs &= \emptyset, \\
A_\preds &= \emptyset, \\
U_\funcs &=
  \bigl\{ (c, D_\sort) \bigm|
    \func \in \funcs',
    \sort \text{ je sorta výsledku } \func,
    c \in \cells_\func \bigr\}, \\
U_\preds &=
  \bigl\{ c \bigm|
    \pred \in \preds',
    c \in \cells_\pred \bigr\}, \\
E &=
  \Bigl\{ e \Bigm|
    \array{c}
        e \text{ vznikne z $\clause \in \clauses$ použitím substituce,
                která každou} \\[-0.3ex]
      \text{proměnnou $\var$ z $\clause$ nahradí hodnotou z $D_\sort$, kde $\sort$
            je sorta $\var$}
    \endarray
    \Bigr\}.
\end{align*}
Výstupem takového volání jsou hledané modely.
Funkce \textproc{Search} používá pomocnou funkci \textproc{Propagate}.
Jejím vstupem je opět pětice
$(A_\funcs, A_\preds, U_\funcs, U_\preds, E)$.
Funkce \textproc{Propagate} pak na danou pětici opakovaně
aplikuje ná\-sle\-du\-jící pravidla, dokud nenastane konflikt nebo
dokud se pětice mění:
\begin{itemize}
% Pravidlo 1 z clanku o SEM:
\item Pro každé $(c, v) \in A_\funcs$ nahradit všechny výskyty $c$ v $E$
  hodnotou $v$.
% Odstranovani splnenych podminek a nesplnenych literalu
% (v clanku o SEM jsou tyto pravidla implicitni):
\item Pro každé $v, v'$ takové, že $v \neq v'$:
  \begin{itemize}
  \item Z $E$ odebrat podmínky, jenž obsahují literál $v \approx v$
    nebo literál $v \not\approx v'$ nebo literál z $A_\preds$.
  \item Z každé podmínky v $E$ odebrat literály tvaru $v \not\approx v$,
    literály tvaru $v \approx v'$ a literály tvaru $\neg \lit$,
    kde $\lit \in A_\preds$.
  \end{itemize}
% Pravidlo 1b z clanku o SEM:
\item Pro každou podmínku s jedním literálem tvaru $c \approx v$
  (resp. $v \approx c$),
  kde $(c, D) \in U_\funcs$ pro nějaké $D$,
  odebrat $(c, D)$ z $U_\funcs$
  a přidat $(c, v)$ do $A_\funcs$.
\item Pro každou podmínku s jedním literálem tvaru $c \not\approx v$
  (resp. $v \not\approx c$),
  kde $(c, D) \in U_\funcs$ pro nějaké $D$,
  odebrat $v$ z $D$.
% Pravidlo 1a z clanku o SEM:
\item Pro každou podmínku s jedním literálem tvaru $c$,
  kde $c \in U_\preds$,
  odebrat $c$ z $U_\preds$
  a přidat $c$ do $A_\preds$.
\item Pro každou podmínku s jedním literálem tvaru $\neg c$,
  kde $c \in U_\preds$,
  odebrat $c$ z $U_\preds$
  a přidat $\neg c$ do $A_\preds$.
% Pravidlo 3 z clanku o SEM:
\item Pro každou dvojici $(c, \{ v \}) \in U_\funcs$
  odebrat $(c, \{ v \})$ z $U_\funcs$
  a přidat $(c, v)$ do $A_\funcs$.
\end{itemize}

V případě, že nastal konflikt, funkce
\textproc{Propagate} vrátí hodnotou \texttt{conflict},
v opačném případě je vrácena nová pětice.

\subsection{Lepší propagace pro SEM}

Popsali jsme základní varianty metod MACE a SEM,
nyní se podíváme na jejich modifikace.
První modifikací, kterou si ukážeme, bude lepší
propagace pro metodu SEM.

Obsahuje-li $E$ podmínku s jedním literálem tvaru $c \approx v$
(resp. $v \approx c$) a je-li $(c, D) \in U_\funcs$ pro nějaké $D$,
pak funkce \textproc{Propagate} přiřadí buňce $c$ hodnotu $v$
bez ohledu na to, zda $v \in D$. Pokud $v \notin D$, dojde
v každém případě ke konfliktu -- lepší by tedy bylo přiřazení vůbec
neprovádět a okamžitě hlásit konflikt.

První dvě pravidla funkce \textproc{Propagate} slouží
ke zjednodušování množiny podmínek $E$.
Tato pravidla využívají množiny $A_\funcs$ a $A_\preds$
a nevyužívají množinu $E$.
Například, máme-li
\[
  E = \bigl\{ \func(\funcG(0)) \approx 1,
              \func(\funcG(0)) \approx \funcG(0) \bigr\}
\]
a obsahuje-li $U_\funcs$ dvojice $(\func(1), D)$
a $(\funcG(0), D)$, kde $D = \{ 0, 1, 2, 3 \}$, pak funkce
\textproc{Propagate} nic neudělá.
Kdybychom však propagaci rozšířili o pravidlo demodulace,
mohli bychom první podmínku $\func(\funcG(0)) \approx 1$
použít ke zjednodušení druhé podmínky $\func(\funcG(0)) \approx \funcG(0)$,
čímž bychom dostali:
\[
  E = \bigl\{ \func(\funcG(0)) \approx 1, 1 \approx \funcG(0) \bigr\}.
\]
S těmito podmínkami si již poradí i původní funkce \textproc{Propagate}
-- buňkám $\func(1)$ a $\funcG(0)$ přiřadí hodnotu 1 a podmínky eliminuje.

Demodulace používá rovnosti, mohli bychom využít i nerovnosti?
Je-li
\[
  E = \bigl\{ \func(2, 3) \approx 4,
              \func(2, \funcG(5)) \not\approx 4 \bigr\},
\]
pak buňce $\funcG(5)$ nelze přiřadit hodnotu 3. Stejný
závěr vyvodíme, když prohodíme rovnost s nerovností
\[
  E' = \bigl\{ \func(2, 3) \not\approx 4,
              \func(2, \funcG(5)) \approx 4 \bigr\}
\]
nebo když informace $\func(2, 3) = 4$ resp. $\func(2, 3) \neq 4$  bude
pocházet z $A_\funcs$ resp. $U_\funcs$ místo z $E$ resp. $E'$.

Obecně, obsahuje-li $E$ podmínky tvaru
\begin{align*}
\func(v_1 \comdots v_n) &\approx v, \\
\func(v_1 \comdots v_{i-1}, c, v_{i+1} \comdots  v_n) &\not\approx v,
\end{align*}
kde $v_1 \comdots v_n \in \natZ$, pak odvodíme, že buňka $c$ nemůže
obsahovat hodnotu $v_i$. Stejný závěr lze učinit, když
v první podmínce bude nerovnost a ve druhé rovnost
nebo když informace $\func(v_1 \comdots v_n) = v$ resp. její
negace nebude pocházet z $E$, ale z $A_\funcs$ resp. $U_\funcs$.
Rovněž lze prohodit levou a pravou stranu rovnosti anebo
nerovnosti. Analogické pravidlo lze formulovat i pro relace.
Tento druh propagace je implementován v hledači modelů Mace4
\cite{mccune03mace4}, kde se nazývá negativní propagace.

V zobecňování bychom mohli pokračovat. Například
z následujících podmínek
\[
  E = \bigl\{ \neg \pred(0, \funcG(2), \funcG(2)),
              \pred(0, \funcG(2), 1) \bigr\}
\]
bychom chtěli odvodit, že buňce $\funcG(2)$ nelze přiřadit hodnotu 1.
K tomu nám negativní propagace, jak jsme ji formulovali, nestačí.
Místo ní bychom mohli použít pravidlo:
Pokud $E$ obsahuje
podmínky tvaru $\pred(s_1 \comdots s_n)$
a $\neg \pred(t_1 \comdots t_n)$, pak buňkám nesmíme přiřadit
hodnoty, aby $s_i = t_i$ pro všechna $i \in \{ 1 \comdots n \}$.
Je zřejmé, že jednu podmínku z $E$ lze nahradit
literálem z $A_\preds$. Například je-li
\[
  E = \bigl\{ \pred(\funcG(1), \funcG(1)) \bigr\}
\]
a $\neg \pred(0, 0) \in A_\preds$, pak buňce $\funcG(1)$
nelze přiřadit hodnotu 0.

% Analogicky můžeme postupovat i u rovností:
% Obsahuje-li $E$ podmínky tvaru
% $s \approx s'$ a $t \not\approx t'$,
% pak buňkám nesmíme přiřadit hodnoty, aby $(s = t) \wedge (s' = t')$
% nebo $(s' = t) \wedge (s = t')$.
%
% Toto analogické pravidlo opět musí uvažovat množiny
% A_\funcs a U_\funcs, aby bylo ostře silnější než negativní propagace
% pro rovnosti.

% Další metoda propagace: Vybrat n-tici podmínek
% a použít zobecněnou hranovou konzistenci: Každé buňce
% zkusit přiřadit každou její hodnotu a pak zkusit najít podporu
% v ostatních buňkách - tj. zda ostatním buňkám jde přiřadit
% hodnota, aby všechny podmínky z vybrané n-tice byly splněny.

\subsection{Opakované použití výrokových klauzulí pro MACE}

Předpokládejme, že chceme opakovaně hledat modely metodou MACE
s tím, že při každém hledání zvětšíme domény některých sort.

Naivním řešením je vytvořit úplně novou instanci SATu pro každé hledání.
To je ovšem zbytečné, neboť nová instance obsahuje skoro
všechny výrokové klauzule z původní instance. Výjimkou
jsou klauzule vytvořené v bodu 1c) pro funkce $\func^\interp$,
kde sorta výsledku $\func$ patří mezi sorty, jejichž doménu zvětšujeme,
a klauzule z~nich odvozené například pomocí učení klauzulí
\cite{silva1997grasp}.

S lepším řešením přišel program Paradox \cite{claessen03paradox}.
Před každým hledáním modelu se vytvoří nová výroková proměnná $A$.
Literál $A$ se přidá do klauzulí vytvářených v~bodu 1c), které
bude třeba odstranit. Jelikož je učení klauzulí založeno na rezoluci,
literál $A$ se rozšíří i do naučených klauzulí, které byly
odvozeny z klauzulí, jenž bude třeba odstranit.
SAT řešič je spuštěn s předpokladem $\neg A$,
tudíž literál $A$ neovlivní nalezený model.
Pro následující hledání s většími doménami jsou klauzule obsahující
literál $A$ odstraněny přidáním jednotkové klauzule $A$.

Opakované hledání modelů metodou MACE se používá pro implementaci
režimu hledání jednoho modelu,
kdy jsou dána čísla $n \leq n'$ z $\nat$ a hledáme
model s doménou velikosti $m$, že $n \leq m \leq n'$.

\subsection{Další pravidla pro zplošťování}

Počet různých proměnných v klauzuli $\clause \in \clauses$
ovlivňuje, do kolika výrokových klauzulí bude $\clause$
zakódována metodou MACE a do kolika podmínek metodou SEM.
Obecně počet výrokových klauzulí a počet podmínek
závisí exponenciálně na počtu různých proměnných.
Například, obsahuje-li klauzule $\clause$ 3 proměnné z~$\vars_{\sort_1}$
a 5 proměnných z $\vars_{\sort_2}$ a je-li $n_{\sort_1} = 4$
a $n_{\sort_2} = 8$, pak počet výrokových klauzulí resp. počet podmínek
bude $4^3 \cdot 8^5 = 2^{21}$.

Jak je vidět, i pro klauzuli s pouhými 8 proměnnými může vzniknout
velké množství výrokových klauzulí resp. podmínek.
Připomeňme navíc, že zplošťování, které je třeba
provést u metody MACE, přidává do klauzulí nové proměnné.
Následující tři modifikace se tedy snaží transformovat
$\clauses$ tak, aby klauzule v $\clauses$ obsahovaly méně proměnných.

Začneme tím, že vylepšíme zplošťování. Oproti pravidlům
pro zplošťování, která jsme uvedli, obsahuje program Paradox \cite{paradox}
navíc následující pravidla:
\begin{itemize}
\item Klauzuli $\clause$, jenž obsahuje literál $\lit$ tvaru
  $\var \not\approx \varY$, můžeme upravit tak,
  že z ní odstraníme literál $\lit$ a všechny výskyty
  $\var$ nahradíme $\varY$.
\item Klauzuli $\clause = \lit_1 \vee \cdots \vee \lit_n$, kde literál
  $\lit_i$ je tvaru $\var \approx \varY$ a literál $L_j$ je tvaru
  $\term \not\approx \varY$ můžeme nahradit klauzulí
  $\clause' = \term \approx \var \vee
  \bigvee_{k \in \{ 1 \comdots n \} \setminus \{ i, j \}} \lit_k$, pokud $\clause'$
  neobsahuje $\varY$. Poznamenejme, že pravidlo rovněž platí,
  když prohodíme levou a pravou stranu některých rovností anebo nerovností.
\end{itemize}
První pravidlo je obsaženo i v článku \cite{claessen03paradox},
druhé je obsaženo pouze v implementaci.

\subsection{Definice termů}

Abychom zploštili klauzuli
\[
  \func(\funcG(\funcC)) \approx \var,
\]
musíme do ní přidat dvě nové proměnné:
\[
  \funcC \not\approx \varZ \vee
    \funcG(\varZ) \not\approx \varY \vee
    \func(\varY) \approx \var.
\]
Je-li velikost každé domény $n$, pak tato klauzule bude
zakódována do $n^3$ vý\-ro\-ko\-vých klauzulí o 3 literálech.

Článek \cite{claessen03paradox} ukazuje způsob, jak to udělat
úsporněji. Pro term $\funcG(\funcC)$ zavedeme zkratku $\funcC'$.
Původní klauzuli nahradíme klauzulí
\[
  \func(\funcC') \approx \var
\]
a přidáme klauzuli
\[
  \funcC' \approx \funcG(\funcC),
\]
která zaručí, že $\funcC'$ je zkratka za $\funcG(\funcC)$.
Zploštěním těchto klauzulí dostaneme
\begin{gather*}
  \funcC' \not\approx \varY \vee \func(\varY) \approx \var, \\
  \funcC \not\approx \varY \vee
    \funcG(\varY) \not\approx \var \vee
    \funcC' \approx \var.
\end{gather*}
Počet výrokových klauzulí bude $2 \cdot n^2$ a počet literálů
$5 \cdot n^2$.

Jako zkratka slouží funkční symbol\footnote{Modely, jenž jsou
výstupem programu, musí interpretovat právě symboly z původní vstupní množiny
klauzulí $\clauses$. Pomocné symboly zavedené
při transformování množiny $\clauses$ jako například zkratka $\funcC'$
nesmí být součástí výstupních modelů. Naopak, pokud symbol
z původní vstupní množiny $\clauses$ v důsledku určitých transformací
z $\clauses$ vypadne, musí být k výstupnímu modelu přidán.
Příkladem transformace, která může vyřadit symboly z $\clauses$,
je zjednodušování -- odstraňuje klauzule, jenž jsou vždy splněné
(klauzule obsahující literál $\term \approx \term$ nebo literály
$\lit$ a $\neg \lit$), odstraňuje klauzule, jenž
jsou subsumovány jinými klauzulemi,
a z klauzulí odstraňuje literály, jenž nejsou nikdy splněné
($\term \not\approx \term$).},
který se nevyskytuje v $\clauses$.
Zkratku můžeme zavést za libovolný term bez proměnných
a lze s ní nahradit více výskytů daného termu i v různých klauzulích.

\subsection{Rozdělování klauzulí}

Třetí modifikace, která snižuje počty proměnných v klauzulích,
je rozdělování klauzulí. Na rozdíl od předchozích dvou modifikací
se používá nejen pro metodu MACE, ale i pro metodu SEM.
Princip této metody je použít více klauzulí k~nahrazení jedné
klauzule $\clause \in \clauses$.
Samozřejmě, každá z nových klauzulí, jimiž nahrazujeme klauzuli $\clause$,
musí obsahovat méně proměnných než $\clause$.

Začneme příkladem. Rozdělíme klauzuli z $\clauses$
\[
\clause = \pred_1(\var) \vee \pred_2(\varY) \vee \pred_3(\var, \varZ)
\]
na dvě klauzule s menším množstvím proměnných.
První dva literály $\clause$ dáme do první klauzule
a zbylý literál $\clause$ do druhé klauzule:
\begin{align*}
  \clause_1 &= \pred(\var) \vee \pred_1(\var) \vee \pred_2(\varY) \\
  \clause_2 &= \neg \pred(\var) \vee \pred_3(\var, \varZ).
\end{align*}
$\pred$ je predikátový symbol, jenž se nevyskytuje v $\clauses$.
Propojovací literály $\pred(\var)$ a $\neg \pred(\var)$ zajišťují,
že každý model původní klauzule $\clause$ jde převést na model
$\clause_1$ a $\clause_2$ rozšířením o vhodnou interpretaci $\pred$.
Pro převod modelu opačným směrem stačí odstranit interpretaci $\pred$.
Klauzuli se třemi proměnnými jsme rozdělili na dvě klauzule po dvou
proměnných. Navíc klauzuli $\clause_1$ můžeme rozdělit
na dvě klauzule po jedné proměnné.

Obecně můžeme klauzuli $\clause \in \clauses$ s literály
$\lit_1 \comdots \lit_n$ rozdělit na dvě klauzule
\begin{align*}
  \clause_1 &= \pred(\var_1 \comdots \var_n) \vee
    \lit_1 \vee \cdots \vee \lit_i, \\
  \clause_2 &= \neg \pred(\var_1 \comdots \var_n) \vee
    \lit_{i+1} \vee \cdots \vee \lit_n,
\end{align*}
kde $\pred$ je predikátový symbol, jenž se nevyskytuje v $\clauses$,
a $\var_1 \comdots \var_n$ jsou proměnné, jenž se vyskytují v
$\lit_1 \comdots \lit_i$ a zároveň v $\lit_{i+1} \comdots \lit_n$.
Rozdělení provádíme pouze v případě, že obě klauzule mají
méně proměnných než $\clause$.

Otázkou je, jak rozdělit literály původní klauzule $\clause$ mezi
$\clause_1$ a $\clause_2$. Algoritmus z článku \cite{tammet03}
od autora programu Gandalf prochází všechny podmnožiny
proměnných z $\clause$ a pro každou podmnožinu $\vars'$
zkouší literály z $\clause$ rozdělit do dvou skupin tak,
aby proměnné sdílené oběma skupinami $\var_1 \comdots \var_n$
byly právě proměnné z $\vars'$. Podmnožiny jsou procházeny
v pořadí od nejmenší po největší -- díky tomu algoritmus
najde podmnožinu minimální velikosti
a predikátový symbol $\pred$ má minimální aritu.

% Arita není nejmenší, je pouze minimální -- arity jsou posloupnosti
% a posloupnosti se stejnou délkou jsou neporovnatelné.

Program Paradox \cite{claessen03paradox} používá jiný postup.
Řekneme, že dvě proměnné jsou v~klauzuli spojené, pokud
existuje literál v němž se obě vyskytují.
Paradox hledá proměnnou $\var$, jenž je spojena s minimem proměnných.
Do klauzule $\clause_1$ dá právě literály obsahující $\var$.
Rozdělení se provede pouze, pokud $\var$ není spojena se všemi proměnnými
(kdyby $\var$ byla spojena se všemi proměnnými, klauzule $\clause_1$
by obsahovala stejný počet proměnných jako $\clause$).

\subsection{Redukce symetrií}

\subsection{Inference sort}

\subsection{Omezení velikosti domén}
