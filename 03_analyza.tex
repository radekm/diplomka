\chapter{Známé metody hledání modelů}

Jak, jsme viděli v minulé kapitole, najít model
velikosti $n$ nebo ukázat, že neexistuje, je snadné --
stačí použít metodu generuj a testuj.
Tuto metodu lze jednoduše implementovat,
kvůli své pomalosti je však prakticky nepoužitelná.
V této kapitole budeme studovat pokročilejší metody
pro hledání modelů, které jsou obvykle rychlejší
než metoda generuj a testuj.
Začneme popisem základních variant metod MACE a SEM,
poté popíšeme modifikace obou metod.
Metody MACE a SEM interně pracují s klauzulemi bez proměnných
a interpretace reprezentují explicitně,
na konci kapitoly pak zmíníme metody, které interně
pracují s klauzulemi s proměnnými a interpretace reprezentují
implicitně.

\section{Metody MACE a SEM}

Obě metody řeší následující úlohu:
Vstupem úlohy je konečná množina
klauzulí $\clauses$ a velikost domény $n_\sort$
pro každou sortu $\sort \in \sorts'$, kde $\sorts'$ je množina
obsahující právě sorty z $\clauses$. Výstupem úlohy jsou číselné modely
nad $\sorts' \cup \funcs' \cup \preds'$, kde domény mají velikosti
$n_\sort$ a $\funcs'$ resp. $\preds'$ je množina obsahující právě funkční
resp. predikátové symboly z $\clauses$.

Všimněme si, že zadání úlohy jednoznačně určuje domény sort
(domény jsou počátečním úsekem $\natZ$ a známe i jejich velikosti).
Díky tomu jsou hledané modely jednoznačně určeny pouze funkcemi a relacemi.
Navíc víme, nad jakými množinami jsou funkce i relace definovány.
Označme $D_\sort = \{ 0 \comdots n_\sort - 1 \}$ doménu
sorty $\sort \in \sorts'$.
Každému funkčnímu symbolu $\func \in \funcs'$ arity
$\langle \sort_1 \comdots \sort_n, \sort \rangle$ pak model přiřazuje funkci
$f^\interp : D_{\sort_1} \timdots D_{\sort_n} \to D_\sort$
a každému predikátovému symbolu $\pred \in \preds'$ arity
$\langle \sort_1 \comdots \sort_n \rangle$
je přiřazena relace $P^\interp \subseteq D_{\sort_1} \timdots D_{\sort_n}$.

\newcommand\cells{\ensuremath{\mathcal{C}}}

Tyto funkce a relace můžeme reprezentovat tabulkou.
Funkce $\func^\interp$ přiřazená symbolu $\func$
s aritou $\langle \sort_1 \comdots \sort_n, \sort \rangle$
je reprezentována tabulkou o rozměrech $n_{\sort_1} \timdots n_{\sort_n}$,
kde buňky tabulky obsahují prvky z $D_\sort$.
\[
\cells_\func = \bigl\{ \func(i_1 \comdots i_n) \bigm| i_j \in D_{\sort_j},
  \text{ kde } j \in \{ 1 \comdots n  \}  \bigr\}
\]
je množina buněk tabulky pro funkci $\func^\interp$.
Buňka $\func(i_1 \comdots i_n)$ obsahuje hodnotu $v$ (zapisujeme
$\func(i_1 \comdots i_n) = v$) právě tehdy,
když $\func^\interp(i_1 \comdots i_n) = v$.

Relace $\pred^\interp$
přiřazená predikátovému symbolu $\pred$ s aritou
$\langle \sort_1 \comdots \sort_n \rangle$
je reprezentována tabulkou o rozměrech $n_{\sort_1} \timdots n_{\sort_n}$,
kde buňky tabulky obsahují prvky 0 nebo 1.
\[
\cells_\pred = \bigl\{ \pred(i_1 \comdots i_n) \bigm| i_j \in D_{\sort_j},
  \text{ kde } j \in \{ 1 \comdots n  \}  \bigr\}
\]
je množina buněk tabulky pro relaci $\pred^\interp$.
Fakt, že buňka $\pred(i_1 \comdots i_n)$ obsahuje hodnotu $v$
zapisujeme $\pred(i_1 \comdots i_n) = v$.
Buňka $\pred(i_1 \comdots i_n)$ obsahuje hodnotu 1
právě tehdy, když $(i_1 \comdots i_n) \in \pred^\interp$.

% Poznámka: Aplikace funkčních resp. predikátových symbolů bez argumentů
% budeme zapisovat bez prázdných závorek tj. c resp. P
% a nikoliv c() resp. P().

V dalším textu budeme hledání modelů metodami MACE a SEM chápat jako
vyplňování tabulek funkcí a relací.

\subsection{MACE -- základní varianta}

Metoda MACE je popsána v \cite{mccune94davis-putnam}.
Jak jsme již řekli v úvodu, metoda MACE převádí problém na SAT.
Napřed vytvoříme instanci SATu, jejíž řešení odpovídají 1 ku 1
tabulkám funkcí\footnote{Pro funkce v této práci používáme přímé kódování.
Existují však i jiné možnosti.
Pokud bychom například chtěli mít méně
výrokových proměnných pro funkce, mohli bychom použít logaritmické kódování.
Nicméně množství proměnných pro funkce nebývá problém,
neboť se obvykle pracuje pouze s malými doménami.
Naopak problém je horší propagace logaritmického kódování.
Různá kódování včetně přímého a logaritmického jsou popsána
v \cite{gavanelli2007}.} a relací:

% Z předchocízho textu je zřejmé, že
% tabulky funkcí a relací odpovídají číselným
% interpretacím nad $\sorts' \cup \funcs' \cup \preds'$, kde doména
% $\sort \in \sorts'$ má velikost $n_\sort$:

\begin{itemize}
\item[1)] Pro každou funkci $\func^\interp$, jejíž tabulku chceme vyplnit:
  \begin{itemize}
  \item[a)] Pro každou buňku $\func(i_1 \comdots i_n)$ a hodnotu $v$,
    kterou daná buňka může obsahovat, přidáme výrokovou proměnnou
    $A_{\func(i_1 \comdots i_n) = v}$.
  \item[b)] Pro každou buňku $\func(i_1 \comdots i_n)$
    a dvojici hodnot $v < v'$,
    které buňka může obsahovat, přidáme klauzuli
    $\neg A_{\func(i_1 \comdots i_n) = v} \vee \neg A_{\func(i_1 \comdots i_n) = v'}$.
  \item[c)] Pro každou buňku $\func(i_1 \comdots i_n)$ a všechny hodnoty
    $0 \comdots v$, jenž může obsahovat, přidáme klauzuli
    $A_{\func(i_1 \comdots i_n) = 0} \vee \cdots \vee A_{\func(i_1 \comdots i_n) = v}$.
  \end{itemize}
\item[2)] Pro každou relaci $\pred^\interp$, jejíž tabulku chceme vyplnit: Pro
  každou buňku $\pred(i_1 \comdots i_n)$ přidáme výrokovou proměnnou
  $A_{\pred(i_1 \comdots i_n) = 1}$.
\end{itemize}

Na základě řešení instance SATu můžeme vyplnit tabulky funkcí a relací:
Výrok $V$ o buňce tabulky bude pravdivý právě tehdy,
když výroková proměnná $A_V$ má v řešení hodnotu 1.
Klauzule z kroku 1b) zajišťují, že každá buňka obsahuje
nejvýše jednu hodnotu. Klauzule z kroku 1c) zajišťují, že každá
buňka obsahuje alespoň jednu hodnotu.

Tabulky, které takto získáme, nejsou nutně modely $\clauses$.
Aby tomu tak bylo, rozšíříme instanci SATu o další výrokové klauzule,
které získáme zakódováním klauzulí z $\clauses$ do výrokové logiky.
Uvažme například klauzuli
$\clause_1 = \{ \func(\var, \varY) \approx \var \vee \funcC \approx \var \}$,
kde $\func$ je funkční symbol arity
$\langle \sort_1, \sort_2, \sort_1 \rangle$, $\funcC$
je funkční symbol arity $\langle \sort_1 \rangle$ a sorta $\sort_1$
resp. $\sort_2$
má doménu velikosti 3 resp. 2.
Aby tabulky symbolů $\func$ a $\funcC$ byly modelem klauzule
$\clause_1$, musí platit následující podmínky:
\begin{gather*}
  \func(0, 0) = 0 \text{ nebo } \funcC = 0, \\
  \func(1, 0) = 1 \text{ nebo } \funcC = 1, \\
  \func(2, 0) = 2 \text{ nebo } \funcC = 2, \\
  \func(0, 1) = 0 \text{ nebo } \funcC = 0, \\
  \func(1, 1) = 1 \text{ nebo } \funcC = 1, \\
  \func(2, 1) = 2 \text{ nebo } \funcC = 2.
\end{gather*}
Uvedené podmínky se skládají z výroků, jenž přímo odpovídají
vý\-ro\-ko\-vým pro\-měnným.
Díky tomu můžeme podmínky snadno zakódovat do výrokových klauzulí:
\begin{gather*}
  A_{\func(0, 0) = 0} \vee A_{\funcC = 0}, \\
  A_{\func(1, 0) = 1} \vee A_{\funcC = 1}, \\
  A_{\func(2, 0) = 2} \vee A_{\funcC = 2}, \\
  A_{\func(0, 1) = 0} \vee A_{\funcC = 0}, \\
  A_{\func(1, 1) = 1} \vee A_{\funcC = 1}, \\
  A_{\func(2, 1) = 2} \vee A_{\funcC = 2}.
\end{gather*}

Klauzuli $\clause_1$ jsme tedy zakódovali do 6 výrokových klauzulí,
které přidáme do naší instance SATu.
Bohužel, ne každou klauzuli jde zakódovat takto přímočaře.
Například, aby tabulky symbolů byly modelem klauzule
$\clause_2 = \func(\funcC, \varY) \approx \funcC$, musí platit podmínky
\begin{gather*}
  \func(\funcC, 0) = \funcC, \\
  \func(\funcC, 1) = \funcC.
\end{gather*}
Na rozdíl od podmínek pro $\clause_1$ výroky v podmínkách pro $\clause_2$
neodpovídají přímo výrokovým proměnným.
Odpovídaly by, kdybychom znali přesnou hodnotu $\funcC$, jenže tu neznáme.
Víme však, že $\funcC$ má jednu z hodnot 0, 1, nebo 2, nabízí se tedy
použít podmiňování. Pokud má $\funcC$ hodnotu 0, pak musí platit
podmínky
\begin{gather*}
  \func(0, 0) = 0, \\
  \func(0, 1) = 0,
\end{gather*}
pokud má $\funcC$ hodnotu 1, musí platit
\begin{gather*}
  \func(1, 0) = 1, \\
  \func(1, 1) = 1,
\end{gather*}
a nakonec, pokud má $\funcC$ hodnotu 2, musí platit
\begin{gather*}
  \func(2, 0) = 2, \\
  \func(2, 1) = 2.
\end{gather*}
Tyto podmínky již do výrokových klauzulí zakódujeme snadno:
\begin{gather*}
  A_{\funcC = 0} \implies A_{\func(0, 0) = 0}, \\
  A_{\funcC = 0} \implies A_{\func(0, 1) = 0}, \\
  A_{\funcC = 1} \implies A_{\func(1, 0) = 1}, \\
  A_{\funcC = 1} \implies A_{\func(1, 1) = 1}, \\
  A_{\funcC = 2} \implies A_{\func(2, 0) = 2}, \\
  A_{\funcC = 2} \implies A_{\func(2, 1) = 2}.
\end{gather*}

Klauzule, které lze zakódovat do výrokových klauzulí
bez podmiňování, nazveme ploché:

\begin{defn}
Klauzule je plochá, pokud má každý atom jeden z následujících tvarů
\begin{itemize}
\item $\func(\var_1 \comdots \var_n) \approx \varY$
  (případně $\varY \approx \func(\var_1 \comdots \var_n)$,
\item $\pred(\var_1 \comdots \var_n)$,
\item nebo $\var \approx \varY$,
\end{itemize}
kde $\func, \pred, \var, \var_1 \comdots \var_n, \varY$ jsou
vhodně zvolené symboly a proměnné.
\end{defn}

Pomocí těchto dvou pravidel můžeme zploštit každou
klauzuli $\clause$:
\begin{itemize}
\item Je-li $\term$ term, jenž se vyskytuje v $\clause$, a $\var$ proměnná,
  jenž se v $\clause$ nevyskytuje, pak klauzuli $\clause$ můžeme
  nahradit novou klauzulí $\term \not\approx \var \vee \clause$.
\item Je-li $\lit$ literál z $\clause$ tvaru $\term \not\approx \var$
  (resp. $\var \not\approx \term$),
  že $\term$ neobsahuje $\var$,
  pak můžeme $\clause$ upravit tak, že jeden výskyt $\term$
  mimo $\lit$ nahradíme $\var$.
\end{itemize}
Navíc má nová klauzule stejné modely jako původní klauzule.

Použití pravidel pro zplošťování si ukážeme na klauzuli $\clause_2$.
Klauzule $\clause_2$ není plochá, neboť obsahuje atom
$\func(\funcC, \varY) \approx \funcC$, který nemá požadovaný tvar
(atom může obsahovat nejvýše jeden výskyt funkčního nebo predikátového
symbolu). Potřebujeme tedy nahradit $\funcC$ proměnnou.
Napřed použijeme první pravidlo a ke klauzuli $\clause_2$ přidáme literál
$\funcC \not\approx \var$, tj. dostaneme novou klauzuli
$\clause_2' = \funcC \not\approx \var \vee
  \func(\funcC, \varY) \approx \funcC$.
Na klauzuli $\clause_2'$ pak můžeme použít dvakrát druhé pravidlo
a nahradit dva výskyty $\funcC$ proměnnou $\var$, čímž
dostaneme plochou klauzuli
$\clause_2'' = \funcC \not\approx \var \vee
\func(\var, \varY) \approx \var$.

Kdybychom zakódovali
$\clause_2''$ do výrokových klauzulí, dostali bychom stejné klauzule,
jako při kódování $\clause_2$ s pomocí podmiňování.
V dalším textu již budeme používat výhradně zplošťování,
důvodem je, že zplošťování může plně nahradit
podmiňování\footnote{Podmiňování je vlastně zplošťování
přímo integrované do procesu, který transformuje klauzule z $\clauses$
na výrokové klauzule. My jsme tento složitější proces rozdělili na dva
jednodušší procesy -- prvním je zplošťování a druhým je transformace
plochých klauzulí z $\clauses$ na výrokové klauzule. Nyní
můžeme oba procesy vylepšovat zvlášť, případně vložit další procesy mezi
ně, což by jinak nebylo možné.}.
Později zplošťování rozšíříme o další pravidla,
díky nimž v některých případech dostaneme méně výrokových klauzulí,
než kdybychom použili podmiňování.

Kódujeme-li plochou klauzuli $\clause$ do výrokových klauzulí,
počet výrokových klauzulí závisí exponenciálně na počtu proměnných
v $\clause$.
Nepříjemnou vlastností zplošťování je, že jeho první pravidlo
zvyšuje počet proměnných v klauzuli. Tato nepříjemnost je hlavní motivací
pro metodu, jenž si nyní představíme.

\subsection{SEM -- základní varianta}

Metoda SEM je popsána v \cite{zhang1995sem}.
Na rozdíl od metody MACE metoda SEM problém nikam nepřevádí, ale rovnou
ho sama řeší.
Pro popis metody SEM budeme předpokládat $v, v' \in \natZ$ a $c$ je buňka.

Metoda SEM sestává ze dvou funkcí \textproc{Search} a \textproc{Propagate}.
Tyto funkce reprezentují stav řešeného problému jako
pětici $(A_\funcs, A_\preds, U_\funcs, U_\preds, E)$:
% U \funcs a \preds nejsou apostrofy -- dolním indexem
% chceme naznačit, že se množina A_\funcs týká funkcí a A_\preds
% týká predikátů.

% A - assigned.
% U - unassigned.
% E - ensure.

% Místo C (jako constraints nebo clauses) používáme E,
% C již označuje klauzule.
\begin{itemize}
\item Množiny $A_\funcs$ a $A_\preds$ obsahují buňky,
  jimž byla přiřazena hodnota. $A_\funcs$ je množina dvojic
  $(c, v)$, kde $c$ je buňka funkce a $v$
  je hodnota přiřazená této buňce. $A_\preds$ je množina
  jejíž prvky mají tvar $c$ nebo $\neg c$, kde $c$ je buňka
  relace. Je-li $c \in A_\preds$, pak je buňce $c$ přiřazena hodnota 1,
  je-li $\neg c \in A_\preds$, pak je buňce $c$ přiřazena hodnota 0.
\item Množiny $U_\funcs$ a $U_\preds$ obsahují buňky,
  jimž nebyla přiřazena hodnota. $U_\funcs$ je množina
  dvojic $(c, D)$, kde $c$ je buňka funkce a $D$
  je množina hodnot, jenž lze přiřadit buňce.
  $U_\preds$ je množina buněk relací.
% Poznámka: Komponenty nemusí být nutně literály podle definice
% z předchozí kapitoly, nicméně nebezpečí nedorozumnění nehrozí.
\item $E$ je množina podmínek, které zbývá splnit.
  Každá podmínka je disjunkce komponent, těmto komponentám
  budeme říkat literály.
\end{itemize}
Invariantem je, že každá buňka má právě jeden výskyt
v právě jedné z~množin $A_\funcs, A_\preds, U_\funcs, U_\preds$.
Konflikt nastává v okamžiku, kdy se v $E$ objeví podmínka bez literálů
nebo kdy se v $U_\funcs$ objeví dvojice tvaru $(c, \emptyset)$.
Model je nalezen v okamžiku, kdy jsou všechny podmínky
splněny (množina $E$ je prázdná) a každé buňce je přiřazena
hodnota (množiny $U_\funcs$ a $U_\preds$ jsou prázdné).
Model je určen množinami $A_\funcs$ a $A_\preds$.

Funkce \textproc{Search} je definována následovně:
\medskip
\begin{algorithmic}
\Function{Search}{$A_\funcs, A_\preds, U_\funcs, U_\preds, E$}
  \State $r \gets \Call{Propagate}{A_\funcs, A_\preds, U_\funcs, U_\preds, E}$
  \If{$r \neq \text{\texttt{conflict}}$}
    \State $(A_\funcs, A_\preds, U_\funcs, U_\preds, E) \gets r$
    \If{$U_\funcs \cup U_\preds = \emptyset$}
      \State \textbf{print model} $(A_\funcs, A_\preds)$
    \Else
      \State $c \gets$ vyber buňku z $U_\funcs \cup U_\preds$
      \If{$(c, D) \in U_\funcs$ pro nějaké $D$}
        \For{$v \in D$}
          \State \Call{Search}{$A_\funcs \cup \{ (c, v) \}, A_\preds,
            U_\funcs \setminus \{ (c, D) \}, U_\preds, E$}
        \EndFor
      \Else
        \State \Call{Search}{$A_\funcs, A_\preds \cup \{ c \},
          U_\funcs, U_\preds \setminus \{ c \}, E$}
        \State \Call{Search}{$A_\funcs, A_\preds \cup \{ \neg c \},
          U_\funcs, U_\preds \setminus \{ c \}, E$}
      \EndIf
    \EndIf
  \EndIf
\EndFunction
\end{algorithmic}
\medskip

Vstupem funkce \textproc{Search} je již zmíněná pětice
$(A_\funcs, A_\preds, U_\funcs, U_\preds, E)$. Výstupem funkce
\textproc{Search} jsou modely, pro výpis modelů se používá příkaz
\textbf{print model}.

Na začátku metoda SEM zavolá funkci \textproc{Search} s argumenty
\begin{align*}
A_\funcs &= \emptyset, \\
A_\preds &= \emptyset, \\
U_\funcs &=
  \bigl\{ (c, D_\sort) \bigm|
    \func \in \funcs',
    \sort \text{ je sorta výsledku } \func,
    c \in \cells_\func \bigr\}, \\
U_\preds &=
  \bigl\{ c \bigm|
    \pred \in \preds',
    c \in \cells_\pred \bigr\}, \\
E &=
  \Bigl\{ e \Bigm|
    \array{c}
        e \text{ vznikne z $\clause \in \clauses$ použitím substituce,
                která každou} \\[-0.3ex]
      \text{proměnnou $\var$ z $\clause$ nahradí hodnotou z $D_\sort$, kde $\sort$
            je sorta $\var$}
    \endarray
    \Bigr\}.
\end{align*}
Výstupem takového volání jsou hledané modely.
Funkce \textproc{Search} používá pomocnou funkci \textproc{Propagate}.
Jejím vstupem je opět pětice
$(A_\funcs, A_\preds, U_\funcs, U_\preds, E)$.
Funkce \textproc{Propagate} pak na danou pětici opakovaně
aplikuje ná\-sle\-du\-jící pravidla, dokud nenastane konflikt nebo
dokud se pětice mění:
\begin{itemize}
% Pravidlo 1 z clanku o SEM:
\item Pro každé $(c, v) \in A_\funcs$ nahradit všechny výskyty $c$ v $E$
  hodnotou $v$.
% Odstranovani splnenych podminek a nesplnenych literalu
% (v clanku o SEM jsou tyto pravidla implicitni):
\item Pro každé $v, v'$ takové, že $v \neq v'$:
  \begin{itemize}
  \item Z $E$ odebrat podmínky, jenž obsahují literál $v \approx v$
    nebo literál $v \not\approx v'$ nebo literál z $A_\preds$.
  \item Z každé podmínky v $E$ odebrat literály tvaru $v \not\approx v$,
    literály tvaru $v \approx v'$ a literály tvaru $\neg \lit$,
    kde $\lit \in A_\preds$.
  \end{itemize}
% Pravidlo 1b z clanku o SEM:
\item Pro každou podmínku s jedním literálem tvaru $c \approx v$
  (resp. $v \approx c$),
  kde $(c, D) \in U_\funcs$ pro nějaké $D$,
  odebrat $(c, D)$ z $U_\funcs$
  a přidat $(c, v)$ do $A_\funcs$.
\item Pro každou podmínku s jedním literálem tvaru $c \not\approx v$
  (resp. $v \not\approx c$),
  kde $(c, D) \in U_\funcs$ pro nějaké $D$,
  odebrat $v$ z $D$.
% Pravidlo 1a z clanku o SEM:
\item Pro každou podmínku s jedním literálem tvaru $c$,
  kde $c \in U_\preds$,
  odebrat $c$ z $U_\preds$
  a přidat $c$ do $A_\preds$.
\item Pro každou podmínku s jedním literálem tvaru $\neg c$,
  kde $c \in U_\preds$,
  odebrat $c$ z $U_\preds$
  a přidat $\neg c$ do $A_\preds$.
% Pravidlo 3 z clanku o SEM:
\item Pro každou dvojici $(c, \{ v \}) \in U_\funcs$
  odebrat $(c, \{ v \})$ z $U_\funcs$
  a přidat $(c, v)$ do $A_\funcs$.
\end{itemize}

V případě, že nastal konflikt, funkce
\textproc{Propagate} vrátí hodnotou \texttt{conflict},
v opačném případě je vrácena nová pětice.

\subsection{Lepší propagace pro SEM}

Popsali jsme základní varianty metod MACE a SEM,
nyní se podíváme na jejich modifikace.
První modifikací, kterou si ukážeme, bude lepší
propagace pro metodu SEM.

Obsahuje-li $E$ podmínku s jedním literálem tvaru $c \approx v$
(resp. $v \approx c$) a je-li $(c, D) \in U_\funcs$ pro nějaké $D$,
pak funkce \textproc{Propagate} přiřadí buňce $c$ hodnotu $v$
bez ohledu na to, zda $v \in D$. Pokud $v \notin D$, dojde
v každém případě ke konfliktu -- lepší by tedy bylo přiřazení vůbec
neprovádět a okamžitě hlásit konflikt.

První dvě pravidla funkce \textproc{Propagate} slouží
ke zjednodušování množiny podmínek $E$.
Tato pravidla využívají množiny $A_\funcs$ a $A_\preds$
a nevyužívají množinu $E$.
Například, máme-li
\[
  E = \bigl\{ \func(\funcG(0)) \approx 1,
              \func(\funcG(0)) \approx \funcG(0) \bigr\}
\]
a obsahuje-li $U_\funcs$ dvojice $(\func(1), D)$
a $(\funcG(0), D)$, kde $D = \{ 0, 1, 2, 3 \}$, pak funkce
\textproc{Propagate} nic neudělá.
Kdybychom však propagaci rozšířili o pravidlo demodulace,
mohli bychom první podmínku $\func(\funcG(0)) \approx 1$
použít ke zjednodušení druhé podmínky $\func(\funcG(0)) \approx \funcG(0)$,
čímž bychom dostali:
\[
  E = \bigl\{ \func(\funcG(0)) \approx 1, 1 \approx \funcG(0) \bigr\}.
\]
S těmito podmínkami si již poradí i původní funkce \textproc{Propagate}
-- buňkám $\func(1)$ a $\funcG(0)$ přiřadí hodnotu 1 a podmínky eliminuje.

Demodulace používá rovnosti, mohli bychom využít i nerovnosti?
Je-li
\[
  E = \bigl\{ \func(2, 3) \approx 4,
              \func(2, \funcG(5)) \not\approx 4 \bigr\},
\]
pak buňce $\funcG(5)$ nelze přiřadit hodnotu 3. Stejný
závěr vyvodíme, když prohodíme rovnost s nerovností
\[
  E' = \bigl\{ \func(2, 3) \not\approx 4,
              \func(2, \funcG(5)) \approx 4 \bigr\}
\]
nebo když informace $\func(2, 3) = 4$ resp. $\func(2, 3) \neq 4$  bude
pocházet z $A_\funcs$ resp. $U_\funcs$ místo z $E$ resp. $E'$.

Obecně, obsahuje-li $E$ podmínky tvaru
\begin{align*}
\func(v_1 \comdots v_n) &\approx v, \\
\func(v_1 \comdots v_{i-1}, c, v_{i+1} \comdots  v_n) &\not\approx v,
\end{align*}
kde $v_1 \comdots v_n \in \natZ$, pak odvodíme, že buňka $c$ nemůže
obsahovat hodnotu $v_i$. Stejný závěr lze učinit, když
v první podmínce bude nerovnost a ve druhé rovnost
nebo když informace $\func(v_1 \comdots v_n) = v$ resp. její
negace nebude pocházet z $E$, ale z $A_\funcs$ resp. $U_\funcs$.
Rovněž lze prohodit levou a pravou stranu rovnosti anebo
nerovnosti. Analogické pravidlo lze formulovat i pro relace.
Tento druh propagace je implementován v hledači modelů Mace4
\cite{mccune03mace4}, kde se nazývá negativní propagace.

V zobecňování bychom mohli pokračovat. Například
z následujících podmínek
\[
  E = \bigl\{ \neg \pred(0, \funcG(2), \funcG(2)),
              \pred(0, \funcG(2), 1) \bigr\}
\]
bychom chtěli odvodit, že buňce $\funcG(2)$ nelze přiřadit hodnotu 1.
K tomu nám negativní propagace, jak jsme ji formulovali, nestačí.
Místo ní bychom mohli použít pravidlo:
Pokud $E$ obsahuje
podmínky tvaru $\pred(s_1 \comdots s_n)$
a $\neg \pred(t_1 \comdots t_n)$, pak buňkám nesmíme přiřadit
hodnoty, aby $s_i = t_i$ pro všechna $i \in \{ 1 \comdots n \}$.
Je zřejmé, že jednu podmínku z $E$ lze nahradit
literálem z $A_\preds$. Například je-li
\[
  E = \bigl\{ \pred(\funcG(1), \funcG(1)) \bigr\}
\]
a $\neg \pred(0, 0) \in A_\preds$, pak buňce $\funcG(1)$
nelze přiřadit hodnotu 0.

% Analogicky můžeme postupovat i u rovností:
% Obsahuje-li $E$ podmínky tvaru
% $s \approx s'$ a $t \not\approx t'$,
% pak buňkám nesmíme přiřadit hodnoty, aby $(s = t) \wedge (s' = t')$
% nebo $(s' = t) \wedge (s = t')$.
%
% Toto analogické pravidlo opět musí uvažovat množiny
% A_\funcs a U_\funcs, aby bylo ostře silnější než negativní propagace
% pro rovnosti.

% Další metoda propagace: Vybrat n-tici podmínek
% a použít zobecněnou hranovou konzistenci: Každé buňce
% zkusit přiřadit každou její hodnotu a pak zkusit najít podporu
% v ostatních buňkách - tj. zda ostatním buňkám jde přiřadit
% hodnota, aby všechny podmínky z vybrané n-tice byly splněny.

\subsection{Opakované použití výrokových klauzulí pro MACE}

Předpokládejme, že chceme opakovaně hledat modely metodou MACE
s tím, že při každém hledání zvětšíme domény některých sort.

Naivním řešením je vytvořit úplně novou instanci SATu pro každé hledání.
To je ovšem zbytečné, neboť nová instance obsahuje skoro
všechny výrokové klauzule z původní instance. Výjimkou
jsou klauzule vytvořené v bodu 1c) pro funkce $\func^\interp$,
kde sorta výsledku $\func$ patří mezi sorty, jejichž doménu zvětšujeme,
a klauzule z~nich odvozené například pomocí učení klauzulí
\cite{silva1997grasp}.

S lepším řešením přišel program Paradox \cite{claessen03paradox}.
Před každým hledáním modelu se vytvoří nová výroková proměnná $A$.
Literál $A$ se přidá do klauzulí vytvářených v~bodu 1c), které
bude třeba odstranit. Jelikož je učení klauzulí založeno na rezoluci,
literál $A$ se rozšíří i do naučených klauzulí, které byly
odvozeny z klauzulí, jenž bude třeba odstranit.
SAT řešič je spuštěn s předpokladem $\neg A$,
tudíž literál $A$ neovlivní nalezený model.
Pro následující hledání s většími doménami jsou klauzule obsahující
literál $A$ odstraněny přidáním jednotkové klauzule $A$.

Opakované hledání modelů metodou MACE se používá pro implementaci
režimu hledání jednoho modelu,
kdy jsou dána čísla $n \leq n'$ z $\nat$ a hledáme
model s doménou velikosti $m$, že $n \leq m \leq n'$.

\subsection{Další pravidla pro zplošťování}

Počet různých proměnných v klauzuli $\clause \in \clauses$
ovlivňuje, do kolika výrokových klauzulí bude $\clause$
zakódována metodou MACE a do kolika podmínek metodou SEM.
Obecně počet výrokových klauzulí a počet podmínek
závisí exponenciálně na počtu různých proměnných.
Například, obsahuje-li klauzule $\clause$ 3 proměnné z~$\vars_{\sort_1}$
a 5 proměnných z $\vars_{\sort_2}$ a je-li $n_{\sort_1} = 4$
a $n_{\sort_2} = 8$, pak počet výrokových klauzulí resp. počet podmínek
bude $4^3 \cdot 8^5 = 2^{21}$.

Jak je vidět, i pro klauzuli s pouhými 8 proměnnými může vzniknout
velké množství výrokových klauzulí resp. podmínek.
Připomeňme navíc, že zplošťování, které je třeba
provést u metody MACE, přidává do klauzulí nové proměnné.
Následující tři modifikace se tedy snaží transformovat
$\clauses$ tak, aby klauzule v $\clauses$ obsahovaly méně proměnných.

Začneme tím, že vylepšíme zplošťování. Oproti pravidlům
pro zplošťování, která jsme uvedli, obsahuje program Paradox \cite{paradox}
navíc následující pravidla:
\begin{itemize}
\item Klauzuli $\clause$, jenž obsahuje literál $\lit$ tvaru
  $\var \not\approx \varY$, můžeme upravit tak,
  že z ní odstraníme literál $\lit$ a všechny výskyty
  $\var$ nahradíme $\varY$.
\item Klauzuli $\clause = \lit_1 \vee \cdots \vee \lit_n$, kde literál
  $\lit_i$ je tvaru $\var \approx \varY$ a literál $L_j$ je tvaru
  $\term \not\approx \varY$ můžeme nahradit klauzulí
  $\clause' = \term \approx \var \vee
  \bigvee_{k \in \{ 1 \comdots n \} \setminus \{ i, j \}} \lit_k$, pokud $\clause'$
  neobsahuje $\varY$. Poznamenejme, že pravidlo rovněž platí,
  když prohodíme levou a pravou stranu některých rovností anebo nerovností.
\end{itemize}
První pravidlo je obsaženo i v článku \cite{claessen03paradox},
druhé je obsaženo pouze v implementaci.

\subsection{Definice termů}

Abychom zploštili klauzuli
\[
  \func(\funcG(\funcC)) \approx \var,
\]
musíme do ní přidat dvě nové proměnné:
\[
  \funcC \not\approx \varZ \vee
    \funcG(\varZ) \not\approx \varY \vee
    \func(\varY) \approx \var.
\]
Je-li velikost každé domény $n$, pak tato klauzule bude
zakódována do $n^3$ vý\-ro\-ko\-vých klauzulí o 3 literálech.

Článek \cite{claessen03paradox} ukazuje způsob, jak to udělat
úsporněji. Pro term $\funcG(\funcC)$ zavedeme zkratku $\funcC'$.
Původní klauzuli nahradíme klauzulí
\[
  \func(\funcC') \approx \var
\]
a přidáme klauzuli
\[
  \funcC' \approx \funcG(\funcC),
\]
která zaručí, že $\funcC'$ je zkratka za $\funcG(\funcC)$.
Zploštěním těchto klauzulí dostaneme
\begin{gather*}
  \funcC' \not\approx \varY \vee \func(\varY) \approx \var, \\
  \funcC \not\approx \varY \vee
    \funcG(\varY) \not\approx \var \vee
    \funcC' \approx \var.
\end{gather*}
Počet výrokových klauzulí bude $2 \cdot n^2$ a počet literálů
$5 \cdot n^2$.

Jako zkratka slouží funkční symbol\footnote{Modely, jenž jsou
výstupem programu, musí interpretovat právě symboly z původní vstupní množiny
klauzulí $\clauses$. Pomocné symboly zavedené
při transformování množiny $\clauses$ jako například zkratka $\funcC'$
nesmí být součástí výstupních modelů. Naopak, pokud symbol
z původní vstupní množiny $\clauses$ v důsledku určitých transformací
z $\clauses$ vypadne, musí být k výstupnímu modelu přidán.
Příkladem transformace, která může vyřadit symboly z $\clauses$,
je zjednodušování -- odstraňuje klauzule, jenž jsou vždy splněné
(klauzule obsahující literál $\term \approx \term$ nebo literály
$\lit$ a $\neg \lit$), odstraňuje klauzule, jenž
jsou subsumovány jinými klauzulemi,
a z klauzulí odstraňuje literály, jenž nejsou nikdy splněné
($\term \not\approx \term$).},
který se nevyskytuje v $\clauses$.
Zkratku můžeme zavést za libovolný term bez proměnných
a lze s ní nahradit více výskytů daného termu i v různých klauzulích.

\subsection{Rozdělování klauzulí}

Třetí modifikace, která snižuje počty proměnných v klauzulích,
je rozdělování klauzulí. Na rozdíl od předchozích dvou modifikací
se používá nejen pro metodu MACE, ale i pro metodu SEM.
Princip této metody je použít více klauzulí k~nahrazení jedné
klauzule $\clause \in \clauses$.
Samozřejmě, každá z nových klauzulí, jimiž nahrazujeme klauzuli $\clause$,
musí obsahovat méně proměnných než $\clause$.

Začneme příkladem. Rozdělíme klauzuli z $\clauses$
\[
\clause = \pred_1(\var) \vee \pred_2(\varY) \vee \pred_3(\var, \varZ)
\]
na dvě klauzule s menším množstvím proměnných.
První dva literály $\clause$ dáme do první klauzule
a zbylý literál $\clause$ do druhé klauzule:
\begin{align*}
  \clause_1 &= \pred(\var) \vee \pred_1(\var) \vee \pred_2(\varY) \\
  \clause_2 &= \neg \pred(\var) \vee \pred_3(\var, \varZ).
\end{align*}
$\pred$ je predikátový symbol, jenž se nevyskytuje v $\clauses$.
Propojovací literály $\pred(\var)$ a $\neg \pred(\var)$ zajišťují,
že každý model původní klauzule $\clause$ jde převést na model
$\clause_1$ a $\clause_2$ rozšířením o vhodnou interpretaci $\pred$.
Pro převod modelu opačným směrem stačí odstranit interpretaci $\pred$.
Klauzuli se třemi proměnnými jsme rozdělili na dvě klauzule po dvou
proměnných. Navíc klauzuli $\clause_1$ můžeme rozdělit
na dvě klauzule po jedné proměnné.

Obecně můžeme klauzuli $\clause \in \clauses$ s literály
$\lit_1 \comdots \lit_n$ rozdělit na dvě klauzule
\begin{align*}
  \clause_1 &= \pred(\var_1 \comdots \var_n) \vee
    \lit_1 \vee \cdots \vee \lit_i, \\
  \clause_2 &= \neg \pred(\var_1 \comdots \var_n) \vee
    \lit_{i+1} \vee \cdots \vee \lit_n,
\end{align*}
kde $\pred$ je predikátový symbol, jenž se nevyskytuje v $\clauses$,
a $\var_1 \comdots \var_n$ jsou proměnné, jenž se vyskytují v
$\lit_1 \comdots \lit_i$ a zároveň v $\lit_{i+1} \comdots \lit_n$.
Rozdělení provádíme pouze v případě, že obě klauzule mají
méně proměnných než $\clause$.

Otázkou je, jak rozdělit literály původní klauzule $\clause$ mezi
$\clause_1$ a $\clause_2$. Algoritmus z článku \cite{tammet03}
od autora programu Gandalf prochází všechny podmnožiny
proměnných z $\clause$ a pro každou podmnožinu $\vars'$
zkouší literály z $\clause$ rozdělit do dvou skupin tak,
aby proměnné sdílené oběma skupinami $\var_1 \comdots \var_n$
byly právě proměnné z $\vars'$. Podmnožiny jsou procházeny
v pořadí od nejmenší po největší -- díky tomu algoritmus
najde podmnožinu minimální velikosti
a predikátový symbol $\pred$ má minimální aritu.

% Arita není nejmenší, je pouze minimální -- arity jsou posloupnosti
% a posloupnosti se stejnou délkou jsou neporovnatelné.

Program Paradox \cite{claessen03paradox} používá jiný postup.
Řekneme, že dvě proměnné jsou v~klauzuli spojené, pokud
existuje literál v němž se obě vyskytují.
Paradox hledá proměnnou $\var$, jenž je spojena s minimem proměnných.
Do klauzule $\clause_1$ dá právě literály obsahující $\var$.
Rozdělení se provede pouze, pokud $\var$ není spojena se všemi proměnnými
(kdyby $\var$ byla spojena se všemi proměnnými, klauzule $\clause_1$
by obsahovala stejný počet proměnných jako $\clause$).

\subsection{Redukce symetrií}

Doposud jsme při hledání jednoho modelu nebo všech neizomorfních modelů
prozkoumávali všechna možná ohodnocení buněk. Nyní si ukážeme,
že to není třeba, že prozkoumáním určitých ohodnocení získáme
informace i o jiných ohodnoceních, která pak prozkoumávat už nemusíme.

Například, když prozkoumáme interpretaci $\interp$,
nemusíme již prozkoumávat interpretace, které jsou s $\interp$ izomorfní.
Toto jednoduché pozorování lze zobecnit pro stavy řešeného
problému.
Mějme dva stavy řešeného problému z metody SEM
$(A_\funcs, A_\preds, U_\funcs, U_\preds, E)$
a $(A_\funcs', A_\preds', U_\funcs', U_\preds', E')$.
Řekneme, že tyto stavy jsou izomorfní,
pokud zpermutováním prvků domén\footnote{Buňky v $A_\funcs, A_\preds$
i podmínky $E$ obsahují prvky domén.
Pokud máme pro každou doménu permutaci,
můžeme tyto permutace použít k přejmenování prvků domén,
jenž se vyskytují $(A_\funcs, A_\preds, E)$.}
dostaneme z trojice $(A_\funcs, A_\preds, E)$
trojici $(A_\funcs', A_\preds', E')$.
Použité permutace tvoří dohromady jednu symetrii.
Jestliže jsou dva stavy řešeného problému izomorfní,
získáme jejich prohledáním izomorfní modely.

% Množiny $E$ a $E'$ se nemusí shodovat,
% stačí, když budou ekvivalentní.

Dalším příkladem jsou symetrické symboly. Uvažme
množinu klauzulí $\clauses$, která obsahuje
predikátové symboly $\pred$ a $\pred'$ takové,
že jejich záměnnou se $\clauses$ nezmění.
Pokud najdeme model $\clauses$, tak záměnnou interpretací
$\pred$ a $\pred'$ získáme jiný model $\clauses$, který
v obecném případě není izomorfní původnímu modelu.
Toto pozorování lze použít i naopak, například,
pokud zjistíme, že žádný model neobsahuje nějakou interpretaci pro $\pred$,
pak automaticky dostaneme, že žádný model neobsahuje tuto interpretaci
ani pro $\pred'$.

Chceme-li metodu SEM modifikovat, aby neprozkoumávala některá
ohodnocení, o nichž získá nebo získala informace
z jiných ohodnocení, máme dvě možnosti:
\begin{itemize}
\item Můžeme upravit množinu podmínek $E$ tak,
  aby některé symetrie přestaly existovat,
\item nebo upravit funkci \textproc{Search}, aby
  neprohledávala symetrické stavy.
\end{itemize}
První možnosti se říká statická modifikace, neboť
pracuje pouze na začátku před spuštěním funkce \textproc{Search}.
Druhé možnosti se říká dynamická modifikace,
jelikož pracuje za běhu funkce \textproc{Search}.

Statická modifikace u metody MACE upraví výrokové klauzule,
dynamická modifikace upravuje samotný SAT řešič.
Nyní popíšeme konkrétní modifikace.

\subsubsection{LNH}

Modifikace LNH \cite{lnh} je založena na následujícím principu:
Uspořádáme-li všechny buňky funkcí do
posloupnosti $c_1 \comdots c_n$,
tak ke každému modelu existuje\footnote{
Takový model můžeme snadno zkonstruovat. Ohodnocené buňky
zapíšeme do posloupnosti $c_1 = v_1 \comdots c_n = v_i$.
Tuto posloupnost procházíme zleva doprava a kdykoliv
najdeme $c_i = v_i$, kde $v_i$ je nepoužitá hodnota, ale není to nejnižší
nepoužitá hodnota $v$, tak v celé posloupnosti zaměníme
$v$ a $v_i$. Tato záměna se nedotkne buněk před $c_i$,
neboť tam se hodnoty $v$ a $v_i$ nevyskytují. U buňky $c_i$ se změní
pouze přiřazená hodnota. Záměna však pokazí pořadí buněk po $c_i$,
pokud se tam $v$ a $v_i$ vyskytují jako argumenty.
Požadovaný model získáme, až dojdeme na konec posloupnosti.
Ze záměn můžeme složit permutace, čímž dostaneme izomorfismus modelů.}
izomorfní model,
kde je každé buňce $c_i$ přiřazena buď nějaká použitá hodnota
nebo nejnižší nepoužitá hodnota.
Mezi použité hodnoty pro buňku $c_i$ patří hodnoty, jenž se vyskytují
jako argument buněk $c_1 \comdots c_i$, a hodnoty
přiřazené buňkám $c_1 \comdots c_{i-1}$.
Pozor, hodnoty z~různých domén chápeme jako různé hodnoty.

Buňka $c_i$ tedy může bez omezení nabývat hodnot, jenž se vyskytují mezi
argumenty $c_1 \comdots c_i$, a také nejnižší hodnoty $v_1$, která se mezi
argumenty $c_1 \comdots c_i$ nevyskytuje.
Jsou-li $v_1 < \cdots < v_{n'}$ hodnoty, jenž jde přiřadit buňce $c_i$
a jenž se nevyskytují mezi argumenty $c_1 \comdots c_i$, pak
buňka $c_i$ může obsahovat hodnotu $v_k$ pro $k \ge 2$ pouze tehdy,
pokud nějaká buňka před $c_i$ obsahuje hodnotu $v_{k-1}$.

Z výše uvedeného vyplývá, jak LNH implementovat jako statickou modifikaci.
Pro buňku $c_i$ a hodnotu
$v_k$, kde $k \in \{ 2 \comdots n' \}$, přidáme podmínku tvaru
\[
c_i \approx v_k \implies
  \bigvee_{\substack{
      j \in \{ 1 \comdots i-1 \}, \\
      \text{$c_i$ a $c_j$ mají stejnou} \\
      \text{sortu výsledku}}}
    c_j \approx v_{k-1}.
\]
$c_j$ označuje buňky nalevo od $c_i$, které mají stejnou sortu
výsledku jako $c_i$, buňky s jinou sortou výsledku
nabývají hodnot z jiných domén, tudíž by rovnost s $v_{k-1}$
nemohla nastat.

Díky těmto podmínkám, nemohou některé buňky nabývat určitých hodnot.
Například, máme-li buňky $\funcC, \func(0, 0), \func(0, 1), \ldots$
a jednu doménu velikosti 3, pak buňka $\funcC$ může nabývat pouze hodnoty
0. Důvodem jsou dvě podmínky, které jsme pro ni vytvořili --
jelikož žádné buňky nejsou nalevo od $\funcC$,
je pravá strana implikace s předpokladem
$\funcC = 1$ resp. $\funcC = 2$ prázdná.

Buňka $\func(0, 0)$ může nabývat pouze hodnot 0, 1. Důvodem
je opět podmínka, kterou jsme pro ni vytvořili:
\[
  \func(0, 0) \approx 2 \implies \funcC \approx 1.
\]
Pravá strana implikace nikdy neplatí, neboť $\funcC = 0$.

Skutečnosti, že některé buňky nenabývají určitých hodnot,
můžeme využít v~metodě MACE při generování výrokových klauzulí.
Jednak pro tyto buňky není třeba generovat některé výrokové proměnné.
Dále klauzule z bodu 1c) pro tyto buňky mohou obsahovat méně literálů
a není třeba je odstraňovat při zvětšení domény. Viz také
\cite{claessen03paradox}.

Velmi důležitou roli hraje pořadí buněk. Například, kdybychom dali
buňku $\func(0, 1)$ jako první, tj.
$\func(0, 1), \funcC, \func(0, 0), \ldots$,
tak by každá buňka mohla nabýt každé hodnoty z domény.
Výroková klauzule z bodu 1c) pro buňku $\func(0, 1)$
by však platila i po zvětšení domény na velikost 4 -- klauzuli
bychom nemuseli odstraňovat.

Pro metodu MACE se LNH obvykle implementuje jako statická modifikace
-- je to jednodušší než upravovat SAT řešič.
Na druhé straně pro metodu SEM se LNH obvykle
implementuje dynamicky -- ve funkci \textproc{Search} stačí nahradit

\medskip
\begin{algorithmic}
  \For{$v \in D$}
    \State \Call{Search}{$A_\funcs \cup \{ (c, v) \}, A_\preds,
      U_\funcs \setminus \{ (c, D) \}, U_\preds, E$}
  \EndFor
\end{algorithmic}
\medskip

\noindent pomocí (liší se pouze první řádek)

\medskip
\begin{algorithmic}
  \For{$v \in D' \cup D'' $}
    \State \Call{Search}{$A_\funcs \cup \{ (c, v) \}, A_\preds,
      U_\funcs \setminus \{ (c, D) \}, U_\preds, E$}
  \EndFor
\end{algorithmic}
\medskip

\noindent
kde $D'$ obsahuje hodnoty z $D$, jenž se vyskytují v $A_\funcs$ nebo
v argumentech $c$,
a $D''$ obsahuje nejmenší hodnotu z $D \setminus D'$,
pokud taková hodnota existuje.
$D'$ je tedy množina použitých hodnot a $D''$ je buď prázdná množina,
nebo obsahuje nejmenší nepoužitou hodnotu.

Pořadí buněk pro LNH je tedy dáno pořadím, v němž byly
buňky ohodnoceny, což znamená, že v různých větvích
prohledávacího stromu může být různé pořadí buněk pro LNH.
Abychom mohli omezit výběr hodnot, tj. omezit velikost $D'$,
je vhodné při výběru neohodnocených buněk z $U_\funcs$
dávat přednost buňkám, jejichž argumenty se již vyskytují v $A_\funcs$.


\subsubsection{XLNH}

Modifikace XLNH \cite{xlnh} redukuje symetrie u problémů
s funkčním symbolem $\func$ arity $\langle \sort, \sort \rangle$.
XLNH lze implementovat jako dynamickou modifikaci metody SEM:

Implementace postupně generuje všechna navzájem
neizomorfní ohodnocení všech buněk
funkcí bez argumentů a všech buněk funkce $\func^\interp$.
S každým takovým ohodnocením $A_\funcs$ je pak spuštěna upravená funkce
\textproc{Search}, která vygeneruje ohodnocení pro zbylé buňky.
Při ohodnocování zbylých buněk využívá upravená funkce \textproc{Search}
rozklad $\func^\interp$ na cykly
k redukci dalších symetrií. Pokud $\func^\interp$ není bijekce,
použije se její bijektivní restrikce.

Článek \cite{xlnh} jednak ukazuje, jak systematicky
generovat neizomorfní ohodnocení všech buněk
funkcí bez argumentů a všech buněk funkce $\func^\interp$.
Dále ukazuje, jak použít $\func^\interp$ k redukci dalších symetrií.

Na rozdíl od modifikace LNH se XLNH staticky neimplementuje.
Důvodem je velké množství podmínek resp. výrokových klauzulí,
jenž by bylo nutné přidat.

\subsubsection{DASH}

Představené modifikace LNH a XLNH nejsou obecně schopny eliminovat všechny
izomorfní modely. Pokud bychom něčeho takového chtěli dosáhnout
v metodě SEM, mohli bychom si pamatovat všechny prohledané
stavy řešeného problému a před prohledáváním nového stavu,
se podívat, zda již nebyl prohledán izomorfní stav.
Taková modifikace by vskutku eliminovala veškeré izomorfní modely
a mohla by tak nahradit modifikace LNH a XLNH -- viz
\cite{audemard2001symmetry}.
Problém spočívá v tom, že stavů řešeného problému
je velmi mnoho, tudíž hledat mezi uloženými stavy izomorfní stav může
dlouho trvat a navíc se tolik stavů ani nemusí vejít do paměti
běžného počítače.

S lepším řešením přišli autoři modifikace DASH \cite{dash}.
Jelikož je na začátku množina podmínek $E$ invariantní
při zpermutování prvků domén, není třeba tuto množinu uvažovat.
Buňky, jimž přiřadila hodnoty funkce \textproc{Propagate},
rovněž není třeba uvažovat, stačí uvažovat pouze buňky,
jimž přiřadila hodnoty funkce \textproc{Search}.
A nakonec, není třeba si pamatovat všechny stavy,
některé stavy jsou redundantní.

Modifikace DASH začíná ohodnocením konstant.
Konstanty jsou ohodnoceny jako při LNH -- jsou uspořádány do posloupnosti
a každé je buď přiřazena hodnota použitá nějakou předchozí konstantou,
nebo nejmenší nepoužitá hodnota. Hodnoty přiřazené konstantám
nejsou záměnné, ostatní hodnoty jsou záměnné.
Prohledané stavy reprezentuje DASH schématy. Schéma je množina
obsahující prvky z $A_\funcs$ a $A_\preds$, jimž byla přiřazena
hodnota funkcí \textproc{Search}. Před prohledáváním jiného
stavu\footnote{Po volání \textproc{Propagate} ve funkci \textproc{Search} --
použití propagace zvyšuje šanci na nalezení schématu, jenž
stavu odpovídá.}
s ohodnocením $A'_\funcs$ a $A'_\preds$ se zkusí najít schéma,
jemuž tento stav odpovídá. Nalezení takového schématu znamená,
že byl prohledán izomorfní stav řešeného problému, tudíž
stav s ohodnocením $A'_\funcs$ a $A'_\preds$ prohledávat nemusíme.
Po prohledání stavu\footnote{Na konci funkce \textproc{Search},
pokud nenastal konflikt.} přidáme schéma,
jenž daný stav reprezentuje,
a odebereme schémata přidaná pro jeho
podstavy\footnote{Schémata přidaná v rekurzivních voláních pro stavy,
jenž vznikly z aktuálního stavu.}.

Dvě schémata jsou izomorfní,
pokud jedno schéma dostaneme z druhého zpermutováním prvků domén mimo
prvků, jenž byly přiřazeny konstantám.
Stav s~ohodnocením $A'_\funcs$ a $A'_\preds$ odpovídá schématu, pokud
prvky nějakého izomorfního schématu leží v množině $A'_\funcs \cup A'_\preds$.

V praxi se ukázalo, že snaha eliminovat všechny izomorfní modely
metodou DASH se nevyplatí. Proto autoři \cite{dash}
v závislosti na hloubce rekurze \textproc{Search} omezují,
jaká schémata se zkouší.

% Hloubka rekurze je hloubka prohledávacího stromu.

DASH se staticky neimplementuje, důvody jsou stejné jako pro XLNH.

\subsection{Omezení velikosti domén}

Dalším trikem, jak zmenšit prohledávaný prostor, je omezit velikost
domén ně\-kte\-rých sort \cite{claessen03paradox}.
Předpokládejme, že hledáme model, kde $n > k$
je velikost domény $D_\sort$, všechny použité funkční symboly
$\funcC_1 \comdots \funcC_k$ se sortou
výsledku $\sort$ jsou bez argumentů a navíc klauzule neobsahují literál
tvaru $\term \approx \term'$, kde $\term, \term'$ jsou termy sorty
$\sort$. Takový model existuje právě tehdy, když
existuje model, kde doména $D_\sort$ má velikost $k$.

Pokud platí předpoklady, lze doménu $D_\sort$ velikosti
$n$ zmenšit odebráním hodnot, jenž nejsou přiřazeny žádné z buněk
$\funcC_1 \comdots \funcC_k$.
Naopak, když máme model s~doménou $D_\sort$ velikosti $k$,
jenž obsahuje prvek $v$, můžeme tuto doménu rozšířit o~hodnoty
$v_1 \comdots v_j$, přičemž hodnotu každé nové buňky $c$ získáme
tak, že výskyty hodnot $v_1 \comdots v_j$ v argumentech buňky $c$ nahradíme
hodnotou $v$, čímž dostaneme jinou buňku $c'$, hodnotu $c$
definujeme jako hodnotu $c'$.

Pozorování můžeme upravit pro případ, kdy klauzule navíc obsahují
literály $\term \approx \term'$,
kde $\term, \term'$ jsou termy sorty $\sort$ a alespoň jeden
z nich není proměnná.
V~takovém případě model s doménou $D_\sort$ velikosti $n$ existuje
právě tehdy, když existuje model s doménou $D_\sort$ velikosti $k + 1$.

Rovnosti termů sorty $\sort$ nepředstavují žádný problém při
zmenšování domény $D_\sort$ z velikosti $n$ na $k + 1$. Při zvětšování domény
víme, že existuje hodnota $v \in D_\sort$, která není přiřazena žádné z buněk
$\funcC_1 \comdots \funcC_k$. Klauzule, které obsahují rovnosti
termů sorty $\sort$, budou splněny i pro hodnoty přidané do domény,
jelikož jsou splněny i pro hodnotu $v$.

Poznamenejme, že ač je klauzule
\[
  \var \approx \funcC
\]
ekvivalentní s klauzulí
\[
  \var \approx \varY \vee \varY \not\approx \funcC,
\]
tak u první klauzule se podaří omezit velikost sorty a u druhé
klauzule se to nepodaří -- druhá klauzule obsahuje rovnost proměnných.
Postup, jak model s menší doménou převést na model s větší doménou
nezaručuje vygenerování všech neizomorfních modelů.
Omezování velikostí domén tedy použijeme pouze v režimu,
kdy hledáme jediný model.

\subsection{Inference sort}

Metody MACE a SEM a jejich modifikace podporují vstupy s více než
jednou sortou. Vstupní množina klauzulí $\clauses$ však obsahuje
nejvýše jednu sortu. Nyní se podíváme, jak vstupní množinu
$\clauses$ transformovat
na množinu $\clauses'$, která potenciálně
obsahuje více sort než $\clauses$.

Pokud bylo původním úkolem najít model $\clauses$, kde je velikost
jediné domény $n$, tak nyní budeme hledat model $\clauses'$,
kde je velikost každé domény $n$. Takový vícesortový
model snadno převedeme na model jednosortový -- stačí zapomenout,
že argumenty a hodnoty buněk jsou z různých sort.

Motivací pro $\clauses'$ s více sortami je skutečnost,
že některé modifikace mají větší šanci omezit prohledávaný prostor,
když $\clauses'$ obsahuje více sort. Například
redukce symetrií LNH má k dispozici více nepoužitých hodnot,
neboť hodnoty z různých domén chápeme jako různé.
Jiným příkladem je omezování velikosti domén -- velikost původní domény
nemusí jít omezit, ale velikost některé z nových domén už ano.

Vraťme se k samotnému převodu $\clauses$ na $\clauses'$.
Používáme techniku z \cite{claessen03paradox}.
Označme
\[
  s = \{ s_{a, n} \mid  a \in \funcs \cup \preds \cup \vars, n \in \nat\}.
\]
Množina $\clauses'$ vznikne z množiny $\clauses$ tak, že
\begin{itemize}
\item každý funkční symbol $\func$ arity
  $\langle \sort_1 \comdots \sort_n, \sort \rangle$
  nahradíme funkčním symbolem $\func'$ arity
  $\langle [s_{\func, 1}]_E \comdots [s_{\func, n}]_E, [s_{\func, n + 1}]_E \rangle$,
\item každý predikátový symbol $\pred$ arity
  $\langle \sort_1 \comdots \sort_n \rangle$
  nahradíme predikátovým symbolem $\pred'$ arity
  $\langle [s_{\pred, 1}]_E \comdots [s_{\pred, n}]_E \rangle$
\item a každou proměnnou $\var \in \vars_\sort$ nahradíme
  proměnnou $\var' \in \vars_{[s_{\var, 1}]_E}$,
\end{itemize}
kde prvky $s_{a, n} \neq s_{a', n'}$ pokud $a \neq a'$ nebo $n \neq n'$
a kde $E$ je nejjemnější ekvivalence na $s$, že když prvky $s/E$
ztotožníme se sortami (různým prvkům $s/E$ budou odpovídat různé sorty),
tak $\clauses'$ bude obsahovat klauzule.

$\clauses'$ by neobsahovala klauzule v případě, že by nesouhlasily
sorty -- term sorty $\sort$ by byl na pozici,
kde je vyžadován term sorty $\sort' \neq \sort$. Kdyby $E$ byla ekvivalence
s jedním blokem, tak by se v $\clauses'$ vyskytovala nejvýše jedna sorta.
Chceme nejjemnější ekvivalenci, aby se v $\clauses'$ vyskytovalo
co nejvíce sort. Požadovanou ekvivalenci lze najít algoritmem union-find.

\section{Další metody hledání modelů}

Metody MACE a SEM jsou úspěšné při řešení mnoha praktických problémů
-- viz například výsledky soutěže CASC \cite{sutcliffe2006casc}.
Na druhé straně existuje i řada poměrně jednoduchých problémů,
s nimiž si tyto metody neporadí. Jedním z takových problémů
je najít model následujících klauzulí:
\begin{gather*}
  \func(\var_1 \comdots \var_{128}) \approx \funcC, \\
  \funcC \not\approx \funcC'.
\end{gather*}
Klauzule mají zjevně model s doménou velikosti 2, kde funkce $\func^\interp$
je konstantní. Metody MACE a SEM však žádný model nenajdou.
Problém spočívá v explicitní reprezentaci tabulky funkce $\func^\interp$.
Pro doménu velikosti 2 obsahuje tato tabulka $2^{128}$ buněk,
takže se ani nevejde do paměti počítače.

Další nepříjemnost metod MACE a SEM uvádí \cite{hillenbrand2013superposition}.
Mějme tyto klauzule:
\begin{gather*}
\func(\var) \approx \var, \\
\pred(\func(\funcG(\var))).
\end{gather*}
V logice prvního řádu, lze
druhou klauzuli zjednodušit pomocí první klauzule na $\pred(\funcG(\var))$.
Pokud klauzule transformujeme na podmínky pro SEM, dostaneme:
\begin{gather*}
\func(\var) \approx v, \\
\pred(\func(\funcG(v))),
\end{gather*}
kde $v$ je prvek domény, tj. číslo z $\natZ$.
Pak ovšem podmínky vzešlé z první klauzule již nejde\footnote{Teoreticky
se  můžeme vrátit k logice prvního řádu a z podmínek
odvodit první klauzuli. Nicméně nevíme o praktické implementaci
metody SEM, která by toto dělala.} použít
ke zjednodušení podmínek z druhé klauzule, důvodem je, že
$\funcG(v)$ není číslo.

Oba příklady naznačují, že by některé problémy bylo vhodné řešit
přímo v~logice prvního řádu. Budeme tedy postupovat podobně
jako u metody MACE, ale místo do výrokové logiky převedeme
problém do logiky prvního řádu, kde z funkčních symbolů
jsou pouze symboly bez argumentů \cite{fmdarwin}.

Začneme zploštěním všech klauzulí. Na rozdíl od zploštění,
jenž jsme popsali pro metodu MACE, budeme navíc požadovat, aby
rovnost termů byla pouze mezi proměnnými.

Dále všechny funkční symboly nahradíme predikátovými symboly.
Pro každý funkční symbol $\func$
vezmeme dosud nepoužitý predikátový symbol
$\pred_\func$ stejné arity. Každý literál tvaru
$\func(\var_1 \comdots \var_n) \not\approx \var$
(resp. $\var \not\approx \func(\var_1 \comdots \var_n)$)
nahradíme literálem $\neg \pred(\var_1 \comdots \var_n, \var)$.

% Alternativně jde pro každý funkční symboly zavést konstantu,
% a pro všechny funkční symboly s n argumenty
% zavést jeden predikátový symbol s n+2 argumenty.
% Pak f(x1 .. xn) != y nahradíme !P(c, x1 .. xn, y).

Poté pro každý prvek $v$ každé domény $D_\sort$ vezmeme
dosud nepoužitý funkční symbol $c_{\sort, v}$ arity $\langle \sort \rangle$.
Pro každé dva funkční symboly $c_{\sort, v} \neq c_{\sort, v'}$
přidáme klauzuli $c_{\sort, v} \not\approx c_{\sort, v'}$.

% Metoda převádí problém pro dokazovač FM-Darwin, který neumí rovnost,
% tudíž tam přidává i opračné nerovnosti
% c_{\sort, v'} \not\approx c_{\sort, v}.

Každá funkce má v každém bodě právě jednu hodnotu -- tento
invariant garantovaly u metody MACE klauzule přidané v bodech 1b) a 1c).
Nyní nám stačí garantovat pouze to, že každá \uv{funkce}
(reprezentovaná relací) má v každém bodě alespoň jednu hodnotu,
což pro každý funkční symbol $\func$ z původního problému vyjádříme klauzulí
\begin{equation} \label{eq:totality}
  \bigvee_{\substack{v \in D_\sort, \\ \text{kde $\sort$ je sorta výsledku $\func$}}}
    \pred_\func(\var_1 \comdots \var_n, c_{\sort, v}).
\end{equation}
Díky tomu, že se $\pred_\func$ ve všech klauzulích kromě
klauzule (\ref{eq:totality}) vyskytuje pouze v negaci,
můžeme nalezené modely transformovat tak, že $\pred_\func$
bude reprezentovat skutečnou funkci.

Jelikož takto zakódovaný problém neobsahuje funkční symboly
s argumenty, jsou domény Herbrandových interpretací konečné.
Abychom tedy našli konečný model, stačí problém předat metodě
pro hledání Herbrandových modelů.
Popsané kódování používají například programy
FM-Darwin \cite{fmdarwin}
a iProver\footnote{Pouze v režimu hledání konečných modelů.} \cite{iprover}.

Samozřejmě metody pro hledání Herbrandových modelů lze použít
i bez popsaného kódování, pak ovšem nalezené modely nemusí
mít konečné domény. Rozsáhlý přehled metod automatického dokazování
v logice prvního řádu za\-lo\-že\-ných na budování
modelů je \cite{bonacina2015}. Tento přehled mj. zmiňuje
i metody Model Evolution \cite{modelevolution}
a Inst-Gen \cite{instgen}, jenž jsou implementovány
v programech FM-Darwin a iProver.
